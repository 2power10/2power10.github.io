<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yi&#39;s weblog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhengyi.me/"/>
  <updated>2018-02-23T14:45:09.000Z</updated>
  <id>http://zhengyi.me/</id>
  
  <author>
    <name>Yi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>std::shared_ptr&lt;void&gt;的工作原理</title>
    <link href="http://zhengyi.me/2017/12/28/how-shared-ptr-void-works/"/>
    <id>http://zhengyi.me/2017/12/28/how-shared-ptr-void-works/</id>
    <published>2017-12-28T15:13:59.000Z</published>
    <updated>2018-02-23T14:45:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="前戏">前戏</span></h2><p>先抛出两个问题</p><ul><li>如果<code>delete</code>一个指针，但是它真实的类型和指针类型不一样会发生什么？</li><li>是谁调用了析构函数？ </li></ul><p>下面这段代码会发生什么有趣的事情？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// delete_diff_type.cpp</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Foo() &#123; cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    ~Foo() &#123; cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FakeFoo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    FakeFoo() &#123; cout &lt;&lt; &quot;FakeFoo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    ~FakeFoo() &#123; cout &lt;&lt; &quot;~FakeFoo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    </span><br><span class="line">    void* vptr = new Foo();</span><br><span class="line">    delete vptr;    // warning</span><br><span class="line">    </span><br><span class="line">//    FakeFoo* ffptr = static_cast&lt;FakeFoo*&gt;(new Foo()); // error</span><br><span class="line">    FakeFoo* ffptr = reinterpret_cast&lt;FakeFoo*&gt;(new Foo());</span><br><span class="line">    delete ffptr;</span><br><span class="line">    </span><br><span class="line">    Foo* fptr = new Foo();</span><br><span class="line">    delete fptr;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输出:</span><br><span class="line">Foo()</span><br><span class="line">Foo()</span><br><span class="line">~FakeFoo()</span><br><span class="line">Foo()</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure><p>看一下汇编代码可以看到<code>main</code>函数主要做了下面这几件事</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; symbol stub for: operator new(unsigned long)</span><br><span class="line">; Foo::Foo at delete_diff_type.cpp:8</span><br><span class="line">; symbol stub for: operator delete(void*)</span><br><span class="line"></span><br><span class="line">; symbol stub for: operator new(unsigned long)</span><br><span class="line">; Foo::Foo at delete_diff_type.cpp:8</span><br><span class="line">; FakeFoo::~FakeFoo at delete_diff_type.cpp:16</span><br><span class="line">; symbol stub for: operator delete(void*)</span><br><span class="line"></span><br><span class="line">; symbol stub for: operator new(unsigned long)</span><br><span class="line">; Foo::Foo at delete_diff_type.cpp:8</span><br><span class="line">; Foo::~Foo at delete_diff_type.cpp:9</span><br><span class="line">; symbol stub for: operator delete(void*)</span><br></pre></td></tr></table></figure><p>从汇编中可以看出，构造造函数和析构函数是编译器根据指针的类型生成的调用代码。而且编译器是不允许没有继承关系的指针之间进行转换的，<code>void*</code> 是个例外，只要不作死用<code>reinterpret_cast</code>把指针转换成不相关的类型是不会有问题的。</p><p>所以上面两个问题大概就有答案了。<code>delete</code>语句会至少产生两个动作，一个是调用指针对应类型的析构函数，然后去调用<code>operator delete</code>释放内存。所以如果<code>delete</code>的指针和其指向的真实类型不一样的时候，编译器只会调用指针类型的析构函数，这也就为什么基类的析构函数需要声明称虚函数才能够保证<code>delete</code>基类指针的时候子类析构函数能够被正确的调用。<br><code>operator delete</code>是都会被调用到的，所以指针指向的那块内存是能够“正常的”被释放掉用。</p><h2><span id="stdshared_ptrltvoidgt-的行为"><code>std::shared_ptr&lt;void&gt;</code> 的行为</span></h2><p>那么这个跟<code>std::shared_ptr&lt;void&gt;</code> 有什么关系呢？</p><p>先看一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Foo() &#123; cout &lt;&lt; &quot;Foo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">    ~Foo() &#123; cout &lt;&lt; &quot;~Foo()&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    shared_ptr&lt;void&gt; vptr = shared_ptr&lt;Foo&gt;(new Foo);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">Foo()</span><br><span class="line">~Foo()</span><br></pre></td></tr></table></figure><p>与第一段代码中类似，不过把<code>void*</code>换成了<code>std::shared_ptr&lt;void&gt;</code>，那么<code>shared_ptr&lt;void&gt;</code>为什么能够调用到正确的析构函数呢？一定是<code>shared_ptr</code>里面搞了什么鬼。</p><h2><span id="stdshared_ptrltvoidgt-为啥能正常工作"><code>std::shared_ptr&lt;void&gt;</code> 为啥能正常工作</span></h2><p>那么就看看源代码看看到底为啥这货能够工作，下面是<em>libcxx</em>中<code>shared_ptr</code>的部分源码，把关键的部分抠出来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/** C1. shared_ptr 构造函数 **/</span><br><span class="line"></span><br><span class="line">template&lt;class _Tp&gt;</span><br><span class="line">template&lt;class _Yp&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::shared_ptr(_Yp* __p,</span><br><span class="line">                            typename enable_if&lt;is_convertible&lt;_Yp*, element_type*&gt;::value, __nat&gt;::type)</span><br><span class="line">    : __ptr_(__p)</span><br><span class="line">&#123;</span><br><span class="line">    unique_ptr&lt;_Yp&gt; __hold(__p);</span><br><span class="line">    typedef typename __shared_ptr_default_allocator&lt;_Yp&gt;::type _AllocT;</span><br><span class="line">    typedef __shared_ptr_pointer&lt;_Yp*, default_delete&lt;_Yp&gt;, _AllocT &gt; _CntrlBlk;</span><br><span class="line">    __cntrl_ = new _CntrlBlk(__p, default_delete&lt;_Yp&gt;(), _AllocT());</span><br><span class="line">    __hold.release();</span><br><span class="line">    __enable_weak_this(__p, __p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** C2. shared_ptr 拷贝构造 **/</span><br><span class="line">template&lt;class _Tp&gt;</span><br><span class="line">inline</span><br><span class="line">shared_ptr&lt;_Tp&gt;::shared_ptr(const shared_ptr&amp; __r) _NOEXCEPT</span><br><span class="line">    : __ptr_(__r.__ptr_),</span><br><span class="line">      __cntrl_(__r.__cntrl_)</span><br><span class="line">&#123;</span><br><span class="line">    if (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__add_shared();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** C3. shared_ptr::__cntrl_ 类型 **/</span><br><span class="line">__shared_weak_count* __cntrl_;</span><br><span class="line"></span><br><span class="line">/** C4. shared_ptr 析构函数 **/</span><br><span class="line"></span><br><span class="line">template&lt;class _Tp&gt;</span><br><span class="line">shared_ptr&lt;_Tp&gt;::~shared_ptr()</span><br><span class="line">&#123;</span><br><span class="line">    if (__cntrl_)</span><br><span class="line">        __cntrl_-&gt;__release_shared();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** C5. __shared_weak_count::__release_shared **/</span><br><span class="line"></span><br><span class="line">bool __release_shared() _NOEXCEPT &#123;</span><br><span class="line">    if (__libcpp_atomic_refcount_decrement(__shared_owners_) == -1) &#123;</span><br><span class="line">    __on_zero_shared();</span><br><span class="line">    return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** C6. __shared_ptr_pointer::__release_shared **/</span><br><span class="line">template &lt;class _Tp, class _Dp, class _Alloc&gt;</span><br><span class="line">/* 重点 !!! virtual !!! */</span><br><span class="line">void</span><br><span class="line">__shared_ptr_pointer&lt;_Tp, _Dp, _Alloc&gt;::__on_zero_shared() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    // __data__ 是 内部工具类__compressed_pair</span><br><span class="line">    // __data_.first().second()是 deleter</span><br><span class="line">    // __data_.first().first() 是 shared_ptr&lt;T&gt; 中T类型的指针</span><br><span class="line">    __data_.first().second()(__data_.first().first());</span><br><span class="line">    __data_.first().second().~_Dp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/** C7. default deleter **/</span><br><span class="line"></span><br><span class="line">template &lt;class _Tp&gt;</span><br><span class="line">struct _LIBCPP_TEMPLATE_VIS default_delete &#123;</span><br><span class="line">    // ... 此处省略若干行</span><br><span class="line">  void operator()(_Tp* __ptr) const _NOEXCEPT &#123;</span><br><span class="line">    delete __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不要慌，给你慢慢道来。</p><p>这个故事简单得说是这样的：</p><ul><li>每一个<code>shared_ptr</code> 内部有一个<code>control block</code>，里面会存放一个要维护的指针，一个计数，一个删除器(<code>deleter</code>)，一个分配(<code>allocator</code>)。这里我们要关心的是删除器。顾名思义，它是用来删除指针的。</li><li><code>shared_ptr</code>中的 有一个<code>__cntrl_</code>即<code>control block</code>。字段的类型是<code>__shared_weak_count</code>指针，这个类是一个非模板类。<code>shared_ptr&lt;T&gt;</code>创建的<code>control block</code>的类型是一个类模板<code>template &lt;class _Tp, class _Dp, class _Alloc&gt; __shared_ptr_pointer</code>继承自<code>__shared_weak_count</code>。 见<strong>代码C3</strong>。</li><li>当创建一个新的<code>shared_ptr</code>的时候，构建一个新的<code>control block</code>。见<strong>代码C1</strong>。</li><li>当一个<code>shared_ptr</code> A赋值或者拷贝构造给另一个<code>shared_ptr</code>B的时候（当然是在类型能够转换的前提下），B会把A的<code>__cntrl_</code>拷一份，同时将其引用加一。注意，这个时候拷贝的是指针，<code>__cntrl_</code>还是指向最初创建的那个对象。见<strong>代码C2</strong>。</li><li>当<code>shared_ptr</code>被析构或者重置的时候会调用<code>__cntrl_-&gt;__release_shared()</code>。见<strong>代码C4</strong>。</li><li><code>__cntrl_-&gt;__release_shared()</code>如果发现当前的计数为-1的时候，调用<code>__on_zero_shared()</code>。见<strong>代码C5</strong>。</li><li><code>__on_zero_shared</code>是一个虚方法，那么它就会调用到最初创建的<code>__shared_ptr_pointer</code>的实现。</li><li><code>__shared_ptr_pointer</code>的实现中是有完整的类型和删除器的信息的。见<strong>代码C6</strong>。</li><li>默认的删除器很简单的执行了<code>delete __ptr</code>操作，因为类型是已知的所以能够正确的调用到析构函数。见<strong>代码C7</strong>。</li></ul><h2><span id="这种实现方式给shared_ptr带来额外好处">这种实现方式给<code>shared_ptr</code>带来额外好处</span></h2><p><em>Effective C++</em>  条款07告诉我们“要为多态基类声明 virtual 析构函数”。当然我认为建议依然有效，但是用了<code>shared_ptr</code>以后带来的一个额外好处就是即便你的析构函数忘记写成<code>virtual</code>也能帮你正确的调用析构函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;前戏&quot;&gt;前戏&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;先抛出两个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;delete&lt;/code&gt;一个指针，但是它真实的类型和指针类型不一样会发生什么？&lt;/li&gt;
&lt;li&gt;是谁调用了析构函数？ &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++11" scheme="http://zhengyi.me/tags/C-11/"/>
    
      <category term="源码阅读" scheme="http://zhengyi.me/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>[学习笔记] Udacity - Responsive Web Design Fundamentals?</title>
    <link href="http://zhengyi.me/2016/10/05/udacity-responsive-web-design-notes/"/>
    <id>http://zhengyi.me/2016/10/05/udacity-responsive-web-design-notes/</id>
    <published>2016-10-05T13:23:38.000Z</published>
    <updated>2016-10-05T13:59:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>这门课程(<a href="https://www.udacity.com/course/responsive-web-design-fundamentals--ud893" target="_blank" rel="external">Responsive Web Design Fundamentals</a>)主要介绍了关于响应式设计的基础概念，常用的技巧，常用的设计模式以及如何对网站进行优化的一些技巧。</p><p>这个课程主要是提供一些思路，涉及到技术的部分也只是介绍了最基本用法，并不会深入某个技术去展开。通过这个课程的学习，我们应该能够对响应式设计有一个基本的了解，能够知道在设计响应式的页面时需要如何做和需要注意的一些地方。</p><p>课程的大纲如下，比较基础，课程还有挺多的练习，通过练习能够掌握一些基本的用法。</p><p><img src="/img/Udacity-RWD-Mindmap.png" alt="Course Structure"></p><h2><span id="为什么要响应式设计why-responsive">为什么要响应式设计？(Why Responsive?)</span></h2><p>响应式设计（Responsive Web Design，通常缩写RWD）是一种网页设计的技术，让网站在不同的设备上能够良好的显示。这个“良好的显示”是指能够给浏览网页者一个好的的体验。在移动设备普及前，一个网站只需要在一定程度上考虑不同尺寸即可，但是移动设备的普及，会引入一些很小尺寸的屏幕而且比例也不确定。这就需要响应式设计。</p><p><anchor>响应式设计除了是一门技术以外</anchor>，更多的是一门艺术，如何安排在不同尺寸上的显示方式很大程度上是设计相关的东西而不是技术相关的东西。</p><p><strong>移动优先</strong></p><p>移动优先的设计方式是指在设计的时候从移动端先开始设计，然后再慢慢的往大尺寸去增强。这样的设计方式能够帮助设计者更好的去思考对于一个网页来说什么是最重要的内容，如何把这些内容合理的摆放才能达到效果。</p><h2><span id="从小开始starting-small">从小开始（Starting Small）</span></h2><p>既然涉及到不同的设备，那么关于尺寸的一些概念就需要在这里先搞清楚。</p><ul><li>设备分辨率（Hardware Resolution/Pixel）</li><li>设备独立像素（Device Independent Pixel）</li><li>CSS像素（CSS Pixel）</li><li>Viewport</li></ul><h3><span id="设备分辨率">设备分辨率</span></h3><p>这个很好理解，指得是设备本身的实际分辨率，也就是说一个设备上事实上分布的像素点的个数。</p><h3><span id="设备独立像素">设备独立像素</span></h3><p>设备独立像素是基于某一个系统的坐标系中的一个物理度量单位，系统会将设备独立的像素转换成设备上的实际像素。<sup>[1]</sup></p><p>举个例子，iPhone 3G和iPhone 4S的物理尺寸都是3.5英寸，它们的设备分辨率分别是320 x 480和640 x 960。但是它们的设备独立分辨率是一样的，都是320 x 480<sup>[2]</sup><sup>[3]</sup>。</p><p>课程中给出了一个很形象的图</p><p><img src="/img/Udacity-RWD-DIP-vs-Hardware-Pixel.png" alt="Compare DIP and Hardware Pixels"></p><h3><span id="css像素">CSS像素</span></h3><p>在浏览器没有缩放的情况下，1个CSS像素对应1个设备独立像素。</p><h3><span id="viewport">Viewport</span></h3><p>Viewport指的是用户在设备上的可视区域，在移动设备上这个可视区域往往比网页上的区域小。所以在老的移动浏览器上，会把页面根据实际的大小渲染出来，如果那个尺寸比手机大，用户则需要通过移动，放大和缩小来进行操作。</p><p>移动版Safari引入了“viewport meta”标签来允许开发控制viewpoint的尺寸和缩放比例，虽然这个不是标准，但是大多数的浏览器目前支持这种做法。</p><p>典型的viewport的使用方法如下，将这个<code>meta</code>标签加到<code>&lt;head&gt;</code>中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br></pre></td></tr></table></figure><p>关于Viewport的内容还有很多，我会另起一篇文章进行深入的学习。</p><h3><span id="从小开始">从“小”开始</span></h3><p>这里的从“小”开始指的是从小屏幕开始设计开发，这个跟上面提到的移动优先的概念是吻合的。</p><div style="display: flex"><br>    <div style="width:50%"><br>    <img src="/img/Udacity-RWD-Big-to-Small.png" alt="Udacity-RWD-Big-to-Small"><br>    </div><br>    <div style="width:50%"><br>    <img src="/img/Udacity-RWD-Small-to-Big.png" alt="Udacity-RWD-Small-to-Big"><br>    </div><br></div><p>作者给出了两个图来解释，我觉得挺形象的。从小到大设计和从大到小设计就如同图中的漏斗一样。从大到小，很可能会误把一些有用的内容给过滤掉，而从小到大则不会。</p><p>另外从小开始设计还能够一开始就考虑到性能相关的问题。</p><h2><span id="逐步构建building-up">逐步构建（Building Up）</span></h2><p>构建一个响应式的引用主要需要用到一下几个概念和技术：</p><ul><li>Media Query</li><li>Breakpoint</li><li>Flexbox</li></ul><h3><span id="media-query">Media Query</span></h3><p>Media query 是实现响应式编程使用的最重要的技术，这个是在CSS中根据某一些条件包含一些样式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width: 480px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: lightgreen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Try it Yourself »</span><br><span class="line">The</span><br></pre></td></tr></table></figure><p>这个是media query的语法定义，举个例子，比如我们想在viewport大于400px时将背景颜色改成红色。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (min-width: 400px) &#123;</span><br><span class="line">    body &#123;</span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="breakpoint">Breakpoint</span></h3><p>使用了media query以后会存在一个或多个点是的某一些样式被引用进来，比如上面的那个media query中400px就称为一个breakpoint（断点）。</p><p>断点的设置也是根据设计而来，没有严格的要求。我们可以在一个断点进行大的UI调整，也可以在断点进行一些细微的调整。这个也是一门艺术，而不是一个技术。</p><p>视频中提到了两个断点的例子，我觉得可以仔细观察一下：</p><ul><li><a href="http://skinnyties.com/" target="_blank" rel="external">http://skinnyties.com/</a></li><li><a href="http://cnn.com" target="_blank" rel="external">http://cnn.com</a></li></ul><h3><span id="flexbox">Flexbox</span></h3><p>Flexbox是flexible box的缩写，是2009年W3C提出了一种新的布局解决方案。目前已经在所有的浏览器上得到支持<sup>[5]</sup>。Flex<br>布局的核心思想是让flex容器有能力去修改其子元素的宽度，高度还有顺序从而更好的使用可用的空间。</p><p>课程中提到的不同响应式设计的模式都是使用flex技术实现的。</p><h2><span id="common-responsive-patterns">Common Responsive Patterns</span></h2><p>课程中提供了四种比较通用的响应式模式，这几种模式只是提供了一种思路。可以根据具体的设计组合使用。</p><h3><span id="column-drop">Column Drop</span></h3><p><img src="/img/Udacity-RWD-Column-Drop.png" alt="Column Drop"></p><h3><span id="mostly-fluid">Mostly Fluid</span></h3><p><img src="/img/Udacity-RWD-Mostly-Fluid.png" alt="Mostly Fluid"></p><h3><span id="layout-shifter">Layout Shifter</span></h3><p><img src="/img/Udacity-RWD-Layout-Shifter.png" alt="Layout Shifter"></p><h3><span id="off-canvas">Off Canvas</span></h3><p><img src="/img/Udacity-RWD-Off-Canvas.png" alt="Off Canvas"></p><h2><span id="optimizations">Optimizations</span></h2><p>课程提供了几个在响应式设计的时候可以注意的优化点，包括图片、字体和表格。</p><h3><span id="图片">图片</span></h3><p>响应式的图片，不仅仅是要求图片的尺寸要正确，最关键的是要保证在不同的尺寸下图片显示出来的主体是一个合理的而不是只显示了一部分或者以不合理的缩放比例展示出来。在另一门<a href="https://www.udacity.com/course/responsive-images--ud882" target="_blank" rel="external">「Responsive Images」</a>有关于响应式图片的深入介绍。</p><h3><span id="字体">字体</span></h3><p>在适当的时候需要调整字体的大小从而使其能够更好地适应当前的尺寸。<br>另外，一行的字数也要控制在一个合理的而范围之内，就英语而言，每行65个字符是比较合适的</p><h3><span id="表格">表格</span></h3><p>表格在尺寸的屏幕上比较尴尬，因为表格的信息量比较大而且往往有比较多的列。对于表格我们可以采用一些策略：</p><ul><li>减少表格列，只显示最重要的信息。</li><li>将列展平，用行的形式显示列。</li><li>将表格放在一个container，将container的样式设置为<code>overflow-x: auto, width: 100%</code>。将滚动的区域控制在一个小范围内。</li></ul><h2><span id="references">References</span></h2><p>[1]: <a href="https://en.wikipedia.org/wiki/Device-independent_pixel" target="_blank" rel="external">Wikipedia - Device-independent pixel</a><br>[2]: <a href="http://www.phonearena.com/phones/compare/Apple-iPhone-4s,Apple-iPhone-3G/phones/5257%2C2962" target="_blank" rel="external">Apple iPhone 4s vs Apple iPhone 3G</a><br>[3]: <a href="http://viewportsizes.com/?filter=iphone" target="_blank" rel="external">Viewport Sizes</a><br>[4]: <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank" rel="external">Mozilla - Using the viewport meta tag to control layout on mobile browsers</a><br>[5]: <a href="http://caniuse.com/#search=flexbox" target="_blank" rel="external">Can I use Flexbox</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这门课程(&lt;a href=&quot;https://www.udacity.com/course/responsive-web-design-fundamentals--ud893&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Responsive Web Des
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Udacity" scheme="http://zhengyi.me/tags/Udacity/"/>
    
      <category term="前端" scheme="http://zhengyi.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="RWD" scheme="http://zhengyi.me/tags/RWD/"/>
    
      <category term="Design" scheme="http://zhengyi.me/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>去「界外」看看</title>
    <link href="http://zhengyi.me/2016/09/29/go-out-border/"/>
    <id>http://zhengyi.me/2016/09/29/go-out-border/</id>
    <published>2016-09-29T13:14:40.000Z</published>
    <updated>2016-10-05T13:18:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多人的生活大部分时间都是处于公司-家的两点一线的状态，不知道你有没有过这样的经历。某一天，你开车开错路或者坐公交坐过站了，突然惊奇的发现就在你附近的一个地方跟你想象的不大一样，有时候还能够发现一些很好玩的地方。</p><p>某天晚上，在家附近吃完晚饭，突发奇想往从来都有去过的街的另一头散步走去。走出不到两公里，惊奇的发现原来离我家这么近的地方竟然还有一处迷你的公园。突然心生感慨，其实很多美好的东西可能就在你附近，只是你一直被一个隐形的边界限定住了你探索的脚步。</p><p>有一种说法是“旅游就是从一个你熟悉的地方跑到你一个别人熟悉的地方”。为什么有人喜欢旅游？因为在一个陌生的地方，人们往往能够发现一些不一样的地方，你去的地方离你越远可能这种差异性更强，能够给你带来的冲击也就越强。反过来，其他地方的人到你所生活的地方也同样会受到类似的冲击。在一个陌生的地方，人们的各个感官都处在兴奋、焦虑的状态，它们会极力得去吸取尽可能多的信息然后在脑子里飞速的运算。走在一个异国的路上，可能路边的一个垃圾桶、一个流浪汉、一个普通的招牌都能够吸引你驻足去观察，因为你从来没见过这样的东西。但如果，你在这个地方待上一段时间，你会发现你变得跟本地人一样，把自己的“感官”关闭了，不再抱有极大的好奇心去观察周遭的事物。因为你养成了习惯，习惯可以让你省去很多的思考，让你很轻松的去完成一件事情。比如说，你从地铁站出来不用思考是往左走还是往右走，你的习惯会把你很自然的带回家。</p><p>旅游只是一个简单的例子，除了旅游以外我们的生活中还有非常多的类似的例子。我认为在几乎所有你做的事情上，这种现象都是存在的。小到刷牙洗脸，大到公司决策，都或多或少的收到习惯的影响。</p><p>我们的大脑很聪明也很懒，它帮我们养成了很多的习惯，这样我们就不需要处处进行思考，很多时候跟着熟悉的感觉就能够完成一件事情了。大脑的聪明是很有必要的，在多数情况下能够让我们变得更轻松。但是，这种聪明也为我们设立了一个无形的边界，一个我们不留意可能都不会去注意到的一个边界。在这个边界内，我们是”安全”的，因为某些路径已经被多次证明过是可行的。</p><p>然而一条“安全”可行的路径不代表这条路径是最优的，即使在当下是最优的，也不代表它在外部条件变化的情况下依然是最优的。所以说这种安全是不可靠的，因为外界的条件不可能永远不变。而且习惯是有一定的惯性的，一个习惯你坚持的越久它的惯性就越大，你要改变它的难度及所带来的痛苦也就越大。</p><p>所以，我的结论是<strong>要需要经常去「界外」看看，让我们拥有随时改变路径的能力</strong>。</p><p>那么这个结论就引出了另外几个问题：</p><ol><li>作为一个身处于边界里面的人如何去发现自己的边界。都说要Think out of box，但是如何才能够发现自己的box？</li><li>发现以后到外面看看，肯定不能是简单地看看就完了。如何保持一个开放的心态去看待界外的事物？</li><li>如何才能够拓宽自己的边界？</li></ol><p>这几个问题，容我再想想。</p><center><em>== end of  file ==</em></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很多人的生活大部分时间都是处于公司-家的两点一线的状态，不知道你有没有过这样的经历。某一天，你开车开错路或者坐公交坐过站了，突然惊奇的发现就在你附近的一个地方跟你想象的不大一样，有时候还能够发现一些很好玩的地方。&lt;/p&gt;
&lt;p&gt;某天晚上，在家附近吃完晚饭，突发奇想往从来都有
      
    
    </summary>
    
    
      <category term="随想" scheme="http://zhengyi.me/tags/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记(5)</title>
    <link href="http://zhengyi.me/2016/09/06/effective-cpp-reading-notes-5/"/>
    <id>http://zhengyi.me/2016/09/06/effective-cpp-reading-notes-5/</id>
    <published>2016-09-06T13:15:57.000Z</published>
    <updated>2016-09-06T13:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="4-设计与声明">4. 设计与声明</span></h2><h3><span id="条款18让接口容易被使用不易被误用">条款18：让接口容易被使用，不易被误用</span></h3><blockquote><ul><li>好的借口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li><li>std::shared_ptr支持定制型删除器（custom deleter）。可防范DLL问题，可被用来自动解除互斥锁等等。</li></ul></blockquote><p>这个条款的思想其实适用于所有的编程语言，只要你写的代码需要被其他地方调用，你都需要考虑接口的易用性。即使不暴露，良好的接口设计也能够提高代码的可读性。作者提出的这几点只是在C++这个语言的基础上需要注意的一些小点，我认为设计一个良好的易用的接口，仅仅做到这几点还远远不够。</p><p><strong>接口一致性</strong></p><p>作者认为除非有充分的理由，否则最好让类型与内置的类型的行为尽量一致。这个可以降低使用者错误使用的概率。</p><p>我想补充的另外一点是，比如你提供一整套的接口，你需要让自己的接口相互保持一致的风格。包括但不仅限于：函数的命名风格、函数的行为尽量保持统一的风格。</p><p><strong>防止误用</strong></p><blockquote><p>任何接口如果要求客户必须记得做某件事情，就是有着“不正确使用”的倾向，因为客户可能会忘记做那件事。</p></blockquote><h3><span id="条款19设计class犹如设计type">条款19：设计class犹如设计type</span></h3><blockquote><p>Class 的设计就是type的设计。在定义一个新type之前，确保阅读了本条目的所有讨论主题。</p></blockquote><ul><li><strong>新type的对象应该如何被创建和销毁？</strong> 这个涉及到构造函数、构造函数以及operator new, operator delete, operator new[], operator delete[]。</li><li><strong>对象的初始化和对象的赋值该有什么样的差别？</strong>这个主要是要考虑构造函数和赋值操作符的行为。</li><li><strong>新type的对象如果被passed by value，意味着什么？</strong></li><li><strong>什么事新type的“合法值”？</strong>这点主要是要注意类型的成员变量和合法性检查。</li><li><strong>你的新type需要配合某个继承图系吗？</strong>如果你继承其他的类，需要考虑它们的函数virtual和non-virtual性。如果你的类可能被继承就需要注意你声明的函数——尤其是析构函数。</li><li><strong>你的新type需要什么样的转换？</strong>如果你的类型需要转换成其他的类型，需要考虑定义显式转换或者隐式转换的函数。</li><li><strong>什么样的操作符和函数对此新type而言是合理的？</strong>参考条款23，24，26.</li><li><strong>谁该取用新type的成员？</strong>这个可以使用者的角度来帮助你判断哪一些成员为public，哪个为protected。</li><li><strong>你的新type有多么一般化（generic）？</strong>如果很一般化，可以考虑设计一个class template。</li><li><strong>你真的需要一个新type吧？</strong>如果只是定义新的derived class以便为既有的class添加功能，那么说不定单纯定义一个或多个non-member函数或template更能够达到目标。</li></ul><p>这些问题并不是那么容易回答，在设计一个类型的时候尽量的去考虑这些问题能够更好地设计出一个易用合理的类型。</p><h3><span id="条款20宁以-pass-by-reference-to-const-替换-pass-by-value">条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</span></h3><blockquote><ul><li>尽量以pass-by-reference-to-const 替换 pass-by-value。前者通常比较搞笑，并可以避免切割问题（slicing problem）。</li><li>以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对于它们而言，pass-by-value往往比较适当。</li></ul></blockquote><p>C++默认的传递对象的方法是by-value的方式，当一个对象有很多的成员变量或者有很深的继承结构。那么对于这个对象的构造和销毁会带来很大的开销。这种情况下用pass by reference的方式就能够节省下这种开始。加上const是避免对传入的参数进行修改。</p><p>Pass by value的另一个问题就是对象切割的问题。如果一个子类对象以pass-by-value的形式传递到一个函数中来，那么它的对象将会被切割而失去子类特有的成员变量，而且同时也会失去多态性。pass-by-reference可以解决这个问题，因为reference往往以指针实现，所以截断对象也同时会保有多态性。</p><p>决定一个对象pass by value还是pass by reference的依据不是简单地类型的成员数量，还要考虑这个类型在拷贝的时候是否会做一些比较昂贵的操作。</p><p>有一些例外，即内置类型，以及STL的迭代器和函数对象。除此之外 pass-by-reference-to-const 优于 pass-by-value。</p><h3><span id="条款21必须返回对象是别妄想返回其reference">条款21：必须返回对象是，别妄想返回其reference</span></h3><blockquote><ul><li>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。</li></ul></blockquote><p>返回一个pointer或者reference指向一个local stack对象明显是不合理的，因为local stack的生命周期在函数返回的时候就已经结束了，那么返回的那个指针或者引用将会指向一块被销毁的对象的内存。</p><p>指向一个heap-allocated的对象也是不合理的，因为你把销毁对象的任务移交给了使用函数的人，很多情况下人们会忘记。或者说所写的代码并没有让他有机会去销毁这个对象。比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Rational&amp; operator * (const Rational&amp; lhs,</span><br><span class="line">const Rational&amp; rhs) &#123;</span><br><span class="line">...</span><br><span class="line">return *result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Rational w, x, y, z;</span><br><span class="line">w = x * y * z;</span><br></pre></td></tr></table></figure><p>只有在类似于单例的情况下，返回一个reference指向一个static的对象是合理的。比如说条款4中FileSystem的例子。</p><h3><span id="条款22将成员变量声明为private">条款22：将成员变量声明为private</span></h3><blockquote><ul><li>切记将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。</li><li>protected 并不比public更具封装性。</li></ul></blockquote><p><strong>为什么public不好？</strong></p><p>public的成员变量破坏了类的封装性，它将成员直接暴露给客户，那么在未来修改字段的时候就会影响到使用者。</p><p><strong>为什么protected也不好？</strong></p><p>有一个原则，即<em>某些东西的封装性与“其内容改变时可能造成的代码破坏量”成反比。</em>如果从这个原则出发的话，protected虽然比public好，但是也并没有好太多。因为如果说你这个类型是对外暴露的，你不能阻止用户继承你这个类型，然后去访问其中的成员变量（C++暂时没有类似于final class的概念）。所以说protected的成员变量也不好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;4-设计与声明&quot;&gt;4. 设计与声明&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;条款18让接口容易被使用不易被误用&quot;&gt;条款18：让接口容易被使用，不易被误用&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;好的借口很容易被正确使
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记(4)</title>
    <link href="http://zhengyi.me/2016/08/15/effective-cpp-reading-notes-4/"/>
    <id>http://zhengyi.me/2016/08/15/effective-cpp-reading-notes-4/</id>
    <published>2016-08-15T13:06:32.000Z</published>
    <updated>2016-09-06T13:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="2-构造析构赋值运算">2 构造/析构/赋值运算</span></h2><h3><span id="条款10令-operator-返回一个-reference-to-this">条款10：令 operator= 返回一个 reference to *this</span></h3><blockquote><ul><li>令赋值（assignment）操作符返回一个 reference to *this。</li></ul></blockquote><p>有以下两个主要原因：</p><ol><li>允许连锁赋值。比如说，<code>int x, y, z; x = y = z;</code></li><li>这个协议被普遍的遵守（包括标准库中的很多类型），为了保持类的行为与其他类一致性。</li></ol><h3><span id="条款11在operator中处理自我赋值">条款11：在operator=中处理“自我赋值”</span></h3><blockquote><ul><li>确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为为仍然正确。</li></ul></blockquote><p>一个对象可能被自我赋值，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Widget w[];</span><br><span class="line">// some operation</span><br><span class="line">w[i] = w[j];//w[i]和w[j]指向同一个对象</span><br></pre></td></tr></table></figure></p><p>可以在operator= 操作中做一下简单的指针比较来避免不必要的操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs) &#123;</span><br><span class="line">    if (this == &amp;rhs) return *this;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你需要在赋值操作中做一些复杂的控制逻辑，你不仅需要保证起“自我赋值安全性”还要保证“异常安全性”。这个会在条款xx中具体进行说明。</p><h3><span id="条款12复制对象时勿忘其每一个成分">条款12：复制对象时勿忘其每一个成分</span></h3><blockquote><ul><li>Copying 函数应该确保复制“对象内的所有成员变量”及“所有base class成分”</li><li>不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。</li></ul></blockquote><p>copy构造函数和copy assignment操作符我们统称为copying函数。当我们自己定义copying务必要确保所有的字段都进行了复制，同事如果有基类要保证相对应的copying函数被正确得调用。</p><p>作者认为虽然说copy构造函数和copy assignment操作符做的操作绝大多数是相同的，但是不应该尝试以某一个copying函数实现调用另一个copying函数。这样的操作并不合理。</p><h2><span id="3-资源管理">3. 资源管理</span></h2><h3><span id="条款13-以对象管理资源">条款13： 以对象管理资源</span></h3><blockquote><ul><li>为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的RAII classes分别是<code>tr1::shared_ptr</code>和<code>auto_ptr</code>(C++ 11 中有<code>std::shared_ptr</code>和<code>std::auto_ptr</code>)</li></ul></blockquote><p>内存泄漏和资源泄露很多情况都是因为一个内存/资源分配在堆上，被用于一个函数内，然后在控制流离开函数的时候没有得到正确的释放。对于这种情况引起的资源泄露，可以把资源包装成对象来实现合理的释放。</p><p>“以对象管理资源” 通常也被称为”资源取得时机便是初始化时机”（<em>Resource Acquisition Is Initialization: RAII</em>）。RAII的两个核心思想：</p><ul><li>获得资源后立刻放进管理对象内。</li><li>管理对象运用析构函数确保资源得到释放。</li></ul><p>我们可以根据自己的需求定制RAII类，同时也可以使用系统提供的智能指针可以用来作为管理对象。</p><ul><li><code>auto_ptr</code> - <code>auto_ptr</code>被销毁时会自动删除它所指之物。它的缺点是，如果多个<code>auto_ptr</code>指向同一个对象，那么那个对象会被删除一次以上。另外通过copy构造函数或copy assignment操作符复制它们的时候，它们会变成null。</li><li><code>shared_ptr</code> -  <code>shared_ptr</code>是一个引用计数原理的智能指针。它能够持续追踪有多少个对象指向某个资源，而且它的复制行为也看上去正常许多。它的缺点是，它无法打破循环引用的问题。</li></ul><h3><span id="条款14在资源管理类中小心copying行为">条款14：在资源管理类中小心copying行为</span></h3><blockquote><ul><li>复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</li><li>普遍而常见的RAII class copying行为是：禁止copying、施行引用计数法（reference counting）。不过其他行为也都可能被实现。</li></ul></blockquote><p>当我们定制RAII对象的时候，需要根据具体的需求来控制其拷贝的行为。不然可能会出现一些“不愉快”的事情。</p><p>拷贝的行为基本有下面几种：</p><ul><li><p><strong>禁止复制。</strong> 很多情况对RAII对象进行复制是不合理的，比如说一个Lock类，保存着一个锁。合理的行为是禁止这个类型的复制行为。</p></li><li><p><strong>对底层资源祭出“引用计数法”。</strong> 如果我们希望保有资源，知道它的最后一个使用者被销毁。这种情况我们就应该在内部使用一个引用计数来管理资源，我们可以用<code>shared_ptr</code>来做引用计数。</p></li><li><p><strong>复制底部资源。</strong>  拷贝时将内部的资源进行一个完整的深层拷贝。比如说，一个字符串被复制的时候，它不仅要复制指向内存中字符串的指针，同时也应该复制对应的字符串内存。</p></li><li><p><strong>转移底层资源的拥有权</strong> 在一些比较特殊的场合可能希望只有一个RAII对象指向一个资源，当被复制的时候，资源的拥有权将会进行转移。这个行为跟<code>auto_ptr</code>的行为是一样的。</p></li></ul><h3><span id="条款15在资源管理类中提供对原始资源的访问">条款15：在资源管理类中提供对原始资源的访问</span></h3><blockquote><ul><li>APIs 往往要求访问原始资源（raw resources），所以每一个RAII classes应该提供一个“取得其所管理之资源”的办法。</li><li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显示转换比较安全，但是隐式转换对客户比较方便。</li></ul></blockquote><p>在一些情况下我们的需要访问资源管理类中的原始资源，这个时候我们就应该提供一个能够获得原始资源的方法。</p><p>这个看上去破坏了封装性，但是资源管理类设计的初衷是为了更好地管理资源的申请和释放，并非对资源进行完全的封装。所以提供获取原始资源的方法也还是比较合理的做法。</p><p>可以通过显式和隐式转换两种方法。</p><p><strong>显式转换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Font &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    FontHandle get() const &#123; return f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>隐式转换</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Font &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    operator FontHandle() const &#123; return f; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然两种方式都可行，但个人认为显式的这种方式更好一些。因为这个可以避免很多不小心进行的转换，只有在需要的时候进行显式的调用。</p><h3><span id="条款16成对使用new和delete时要采用相同形式">条款16：成对使用new和delete时要采用相同形式</span></h3><blockquote><p>如果你在new表达式中使用[]，必须在相对应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相对应的delete表达式中使用[]</p></blockquote><h3><span id="条款17以独立语句将newed对象置入智能指针">条款17：以独立语句将newed对象置入智能指针</span></h3><blockquote><p>以独立语句将newed对象存储于智能指针内。如果不这么做，一旦异常被抛出，有可能导致难以察觉的资源泄露。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int priority();</span><br><span class="line">void processWidget(std::shared_ptr&lt;Widget&gt; pw, int p);</span><br><span class="line"></span><br><span class="line">// Bad</span><br><span class="line">processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), priority());</span><br><span class="line"></span><br><span class="line">// Good</span><br><span class="line">std::shared_ptr&lt;Widget&gt; pw(new Widget)</span><br><span class="line">processWidget(pw, priority());</span><br></pre></td></tr></table></figure><p>为什么第一个例子有问题？因为在C++编译器生成代码的时候有可能会出现以下这种情况：</p><ol><li>执行”new Widget”</li><li>调用priority()</li><li>调用std::shared_ptr构造函数</li></ol><p>如果第二部抛出异常，那么第一步申请出来的资源还未放入智能指针内，所以没有人去释放它。于是就造成了资源泄露。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;2-构造析构赋值运算&quot;&gt;2 构造/析构/赋值运算&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;条款10令-operator-返回一个-reference-to-this&quot;&gt;条款10：令 operator= 返回一个 reference to *t
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记(3)</title>
    <link href="http://zhengyi.me/2016/07/06/effective-cpp-reading-notes-3/"/>
    <id>http://zhengyi.me/2016/07/06/effective-cpp-reading-notes-3/</id>
    <published>2016-07-06T13:13:10.000Z</published>
    <updated>2016-07-06T13:14:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="2-构造析构赋值运算">2 构造/析构/赋值运算</span></h2><h3><span id="条款05了解c默默编写并调用哪些函数">条款05：了解C++默默编写并调用哪些函数</span></h3><blockquote><p>编译器可以暗自为class创建<em>default</em>构造函数、<em>copy</em>构造函数、<em>copy assignment</em>操作符，以及析构函数。</p></blockquote><p>定义一个啥也没有的类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123; &#125;</span><br></pre></td></tr></table></figure><p>编译器有可能会帮你生成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;</span><br><span class="line">public:</span><br><span class="line">  Empty() &#123;...&#125;     //默认构造函数</span><br><span class="line">  Empty(const Empty&amp; rhs) &#123;...&#125; //拷贝构造函数</span><br><span class="line">  ~Empty()&#123;...&#125;     //析构函数</span><br><span class="line">  Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125; // copy assignment操作符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是否生成这些方法取决于使用的时候是否需要，比如下面这段代码就用到了这些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Empty e1;//默认构造函数</span><br><span class="line">//析构函数</span><br><span class="line">Empty e2(e1);//拷贝构造函数</span><br><span class="line">e2 = e1;//copy assignment操作符</span><br></pre></td></tr></table></figure><h3><span id="条款06若不想使用编译器自动生成的函数就该明确拒绝">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</span></h3><blockquote><ul><li>为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用像<code>Uncopyable</code>这样的base class也是一种做法。</li></ul></blockquote><p>正如条款5中提到的，即使你自己没有显示定义，编译器默认会为我们创建一些函数。而在某一些条件下，这些函数所带来的行为并不是你想要的。</p><p>那么这个时候你就应该把你想要隐藏的方法声明为private并不提供任何的定义，这样任何尝试去使用的人都会收到一个链接错误。</p><p><strong><em>什么的场景下可能需要使用这种方法？</em></strong></p><ul><li>private 构造函数<br>当你希望用户不能够随意的自己去创建实例而是通过某种方法获得一个实例的时候。比如说单例模式。</li><li>private 析构函数<br>当你希望一个实例的生命周期由另一个类来管理的时候使用。比如说，你需要你的实例使用引用计数，如果不是0则不能够析构。这个时候你就需要提供比如说：Acquire，Release的方法。我觉得如果只是reference count的话，利用shared_ptr也能够实现类似的功能。<br>参考链接：<a href="https://blogs.msdn.microsoft.com/larryosterman/2005/07/01/private-destructors/" target="_blank" rel="external">Private Destructors</a></li><li>private 拷贝构造函数和copy assignment 操作符<br>当你希望一个对象是不可拷贝的时候。<br>Example: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class Uncopyable &#123;</span><br><span class="line">...</span><br><span class="line">private:</span><br><span class="line">    Uncopyable(const Uncopyable&amp;);</span><br><span class="line">    ~Uncopyable&amp; operator=(const Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3><span id="条款07为多态基类声明virtual析构函数">条款07：为多态基类声明virtual析构函数</span></h3><blockquote><ul><li>polymoriphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数</li><li>Classes的设计目的如果不是作为base classes使用，或者不是为了具备多态性（polymorphically），就不该声明virtual析构函数。</li></ul></blockquote><p><strong><em>为什么带有多态性质的基类应该声明一个virtual析构函数？</em></strong></p><p>带有多态性质的基类意味着一个基类的指针可能存放着子类的实例。在这种情况下如果析构函数没有声明为virtual的话，delete一个基类指针不能够正确的调用到子类的析构函数。这就意味着会造成资源的泄露。</p><p>但是如果一个类设计的时候没有想让别的类继承，如果另一个类继承了，就可能会出现资源的泄露。因为C++在语言层面没有提供类似于C# seal的语法，所以没有办法杜绝这种情况。如果发现一个类的析构函数不是virtual的那么就不应该去继承它。</p><p>反过来看就更简单了，如果一个类设计的目的不是作为基类使用，也就意味着它的指针不可能指向一个子类的对象。那么声明成virtual的就没有太大必要，反而会因为virtual而增长了这个对象的内存大小。</p><h3><span id="条款08别让异常逃离析构函数">条款08：别让异常逃离析构函数</span></h3><blockquote><ul><li>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或者结束程序。</li><li>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。</li></ul></blockquote><p><strong><em>为什么析构函数中抛出异常不好？</em></strong></p><ol><li>析构函数被调用的地方不好控制，而且不好对其进行处理。因为任何对象都有析构函数，你不可能在任何地方对异常进行捕捉。（自己补充的）</li><li>如果析构函数中所抛出异常未处理会导致未定义行为。</li></ol><p>所以如果在析构函数中有可能执行到一些会抛异常的方法，需要对其进行捕捉。如果你认为异常可以忍受则默默吞下，记下log，否则记下log然后直接结束程序。</p><p><strong><em>有什么更好的办法？</em></strong></p><p>如果在析构函数里需要进行某个可能抛出异常的方法，那么就应该提供一个普通方法允许用户自己调用。这样子用户就有机会自己对其进行处理。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class DBConn &#123;</span><br><span class="line">public:</span><br><span class="line">   ~DBConn() &#123;</span><br><span class="line">     db.close();   //bad, may throw exception</span><br><span class="line">   &#125;</span><br><span class="line">private:</span><br><span class="line">  DBConnection db;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DBConn &#123;</span><br><span class="line">public:</span><br><span class="line">   void close() &#123;</span><br><span class="line">     db.close();</span><br><span class="line">     closed = true;</span><br><span class="line">   &#125;</span><br><span class="line">   ~DBConn() &#123;</span><br><span class="line">     if (!closed) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">     db.close();   //good, catch exception and provide normal method to close</span><br><span class="line">   &#125;</span><br><span class="line">   catch (...) &#123;</span><br><span class="line">   //log</span><br><span class="line">   &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">private:</span><br><span class="line">  DBConnection db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;2-构造析构赋值运算&quot;&gt;2 构造/析构/赋值运算&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;条款05了解c默默编写并调用哪些函数&quot;&gt;条款05：了解C++默默编写并调用哪些函数&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;编译器可以暗自
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记(2)</title>
    <link href="http://zhengyi.me/2016/06/28/effective-cpp-reading-notes-2/"/>
    <id>http://zhengyi.me/2016/06/28/effective-cpp-reading-notes-2/</id>
    <published>2016-06-28T13:55:42.000Z</published>
    <updated>2016-06-28T13:56:01.000Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="条款4确定对象被使用前已先被初始化">条款4：确定对象被使用前已先被初始化</span></h3><blockquote><ul><li>为内置型对象进行手工初始化，因为C++不保证初始化它们。</li><li>构造函数最好使用成员初值列（member initialization list），而不是在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，起排序次序应该和它们在class中的声明次序相同。</li><li>为了免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</li></ul></blockquote><p>内置对象指的是C++自带的类似于int，double的类型。这些类型变量如果没有进行初始化，其值是未定义的，如果对其进行读取会导致不明确的行为（undefined behavior）。所以必须要保证读取内置对象前，其被初始化过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x; // bad code</span><br><span class="line">int x = 0; // good code</span><br></pre></td></tr></table></figure><p>对于非内置类型，初始化的任务则是由构造函数负责的。包括STL库里的一些类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str;//it&apos;s ok</span><br><span class="line">std::string str = &quot;&quot;; //it&apos;s also ok</span><br><span class="line">Class1 obj;</span><br></pre></td></tr></table></figure><p><strong>类成员变量初始化 vs 赋值</strong></p><p>类的成员变量在进入构造函数之前已经已经被初始化，所以如果在构造函数内进行”初始化“的的话其实是进行赋值，会带来额外的开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Entry &#123;</span><br><span class="line">public:</span><br><span class="line">Entry();</span><br><span class="line">private:</span><br><span class="line">std::string name;</span><br><span class="line">int value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry::Entry() &#123;</span><br><span class="line">name = &quot;default&quot;; //</span><br><span class="line">value = 0;        // not good </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry::Entry()</span><br><span class="line">  : name(&quot;default&quot;)</span><br><span class="line">  , value(0)</span><br></pre></td></tr></table></figure><p>至于作者提到的初值列中的顺序需要与class内变量声明的顺序保持一致是因为c++总是按照class内变量声明的顺序对变量，所以为了避免带来迷惑以及容易检查是否漏掉变量未初始化，最好将初值列顺序与class内变量声明顺序保持一致。</p><p><strong>non-local static 对象的初始化</strong></p><p>不同<strong>编译单元</strong>内定义的<strong>non-local static</strong>对象初始化次序未定义。</p><p><em>编译单元</em></p><p>编译单元是指产出单一目标文件（object file）的那些源码，基本上是它的源文件加上其所含入的头文件。</p><p><em>non-local static 对象</em></p><p>除了定义在函数内的static变量，其他的static变量均是non-local static对象，包括global对象、定义域namespace作用域内的对象、class内的、文件作用域内的static对象。</p><p>次序未定义会导致一个问题，就是如果你需要在一个编译单元内使用另一个编译单元的静态变量，则很有可能你在调用的时候其还没有初始化。这种情况你可以通过使用返回一个local static变量的reference的方法来得到，这个方法就是单例的常见使用场景。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileSystem &amp;tfs() &#123;</span><br><span class="line">   static FileSystem fs;</span><br><span class="line">   return &amp;fs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个还有一个问题就是static在多线程的情况下会出现不确定性，所以最好在程序启动时先以单线程的方式调用一遍。</p><p><strong>总之</strong>，non-local static对象最好只在一个编译单元内使用，如果需要跨编译单元使用，则使用单的方法替代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3&gt;&lt;span id=&quot;条款4确定对象被使用前已先被初始化&quot;&gt;条款4：确定对象被使用前已先被初始化&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为内置型对象进行手工初始化，因为C++不保证初始化它们。&lt;/li&gt;
&lt;li&gt;构造函数最好使用成员初值列（mem
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>《Effective C++》读书笔记(1)</title>
    <link href="http://zhengyi.me/2016/06/24/effective-cpp-reading-notes-1/"/>
    <id>http://zhengyi.me/2016/06/24/effective-cpp-reading-notes-1/</id>
    <published>2016-06-24T12:31:22.000Z</published>
    <updated>2016-06-28T13:53:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="让自己习惯c">让自己习惯C++</span></h2><h3><span id="条款01视c为一个语言联邦">条款01：视C++为一个语言联邦</span></h3><blockquote><ul><li>C++ 高效编程守则是状况而变化，取决于你使用C++的哪一个部分。</li></ul></blockquote><p>C++并不是一个单一范式编程语言，它同时支持过程形式（procedural），面向对象设计（object-oriented）、函数形式（functional）、泛型形式（generic），元编程形式（meta-programming）。</p><p>所以作者认为并不是每一个规则都是适用于所有的这些范式的，那么我们可以将C++语言分为一下几种次语言：</p><ul><li>C</li><li>Object-Oriented C++</li><li>Template C++</li><li>STL</li></ul><h3><span id="条款02尽量以constenuminline替换define">条款02：尽量以const，enum，inline替换#define</span></h3><blockquote><ul><li>对于单纯常量，最好以const对象或enums替换#define</li><li>对于形似函数的宏（macros），最好改用inline函数替换#define</li></ul></blockquote><p><strong>#define的缺点：</strong></p><ol><li>define 定义的值无法被编译器和调试器看到，出问题了很麻烦。</li><li>没有良好的封装新，不能控制作用域。</li></ol><p><strong>const</strong></p><p>使用const我可以这样声明一个常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const std::string ProductName(&quot;Mango Game&quot;);</span><br><span class="line">const double Pi = 3.1415;</span><br></pre></td></tr></table></figure><p>还可以声明一个类的专属常量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Header</span><br><span class="line">class Game &#123;</span><br><span class="line">private:</span><br><span class="line">static const int MaxGamePlayer ;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//cpp file</span><br><span class="line">const int Game::MaxGamePlayer = 5;</span><br></pre></td></tr></table></figure><p><strong>enum hack</strong></p><p>如果需要编译时使用到常量就需要enum hack这个技巧，实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">    enum &#123; NumTurns = 5&#125;</span><br><span class="line">    int scores[NumTruns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>inline function</strong></p><p>有一些宏长得很像函数，这种宏有类型安全问题和不可预料行为两个问题。可以使用inline function来替代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个MAX宏很不好，会出现奇怪的一些问题且无法调试</span><br><span class="line">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line"></span><br><span class="line">//Good</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline T Max(const T&amp; a, const T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="条款3尽可能使用const">条款3：尽可能使用const</span></h3><blockquote><ul><li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li><li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li><li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li></ul></blockquote><p>const提供一种语义上的约束，它能够约束变量使用者的行为。当它作用于针、智能指针、迭代器上的时候可以指向指针本身也可以是指针指向物。作者提出了一个识别的技巧：<em>如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量。</em></p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">char greeting[] = &quot;Hello&quot;</span><br><span class="line">char *p = greeting;//non const point, const data</span><br><span class="line">const char * p = greeting;//non const point, const data </span><br><span class="line">char const * p = greeting;//non const point, const data</span><br><span class="line">char * const p = greeting;//const point, non const data</span><br><span class="line">const char* const p = greeting; //const point, const data</span><br><span class="line"></span><br><span class="line">const std::vector&lt;int&gt;::iterator it;// --&gt; T * const p</span><br><span class="line">*it = 10; //合法</span><br><span class="line">it++;//不合法</span><br><span class="line">std::vector&lt;int&gt;::const_iterator it;// --&gt; const T * p</span><br><span class="line">it = 10;//不合法</span><br><span class="line">it++;//合法</span><br><span class="line"></span><br><span class="line">std::shared&lt;T&gt; p1;</span><br><span class="line">std::shared&lt;const T&gt; p;// --&gt; const T *p</span><br><span class="line">p = p1;//合法</span><br><span class="line">*p.get() = x;//不合法</span><br><span class="line">const std::shared&lt;T&gt; p; // --&gt; T* const p</span><br><span class="line">p = p1;//不合法</span><br><span class="line">*p.get() = x;//合法</span><br></pre></td></tr></table></figure><p>有点头晕，我有一个不是很恰当地记忆方法。可以把<code>const</code>看成修饰它右边所有内容的，以<code>const char* p</code>为例，把<code>p</code>看成一个指针，而<code>*p</code>则是数据，所以<code>const</code>是修饰数据的。而<code>char * const p</code>中，<code>const</code>右边只有<code>p</code>，所以它只是限制指针本身的。</p><h4><span id="bitwise-constness-vs-logical-constness">bitwise constness vs logical constness</span></h4><p>当限制一个成员函数为const，编译器会执行bitwise constness，即检查函数内部是否修改了类的成员变量。但是写代码的时候应该注意逻辑上的常量限制，比如说一个你返回了一个指向内部变量的指针，这个函数虽然符合编译器的const限制但却不是很好的一个写法。</p><p>[to be continued]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;让自己习惯c&quot;&gt;让自己习惯C++&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;条款01视c为一个语言联邦&quot;&gt;条款01：视C++为一个语言联邦&lt;/span&gt;&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;C++ 高效编程守则是状况而变化，取决
      
    
    </summary>
    
      <category term="编程语言" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C++" scheme="http://zhengyi.me/tags/C/"/>
    
      <category term="编程语言" scheme="http://zhengyi.me/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习 - grep</title>
    <link href="http://zhengyi.me/2016/06/06/learning-shell-grep/"/>
    <id>http://zhengyi.me/2016/06/06/learning-shell-grep/</id>
    <published>2016-06-06T13:45:02.000Z</published>
    <updated>2016-06-06T13:58:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="背景知识">背景知识</span></h2><p>grep是linux中常用的文本处理的工具，与之类似的工具有sed和awk，它们分别适用于不同的场景。同时要想很好的使用grep等文本处理工具，需要对正则表达式有一定的了解。</p><h3><span id="grep-vs-sed-vs-awk">grep vs sed vs awk</span></h3><p>grep主要用于对文本、文件进行搜索，查找出符合要求的字符串并输出相关的内容。</p><p>sed和awk则是更强大文本处理工具，适用于更复杂的场景。sed是一个基于字符流的处理工具（stream editor），不仅可以查找文字还可以对文本进行操作，比如说修改、删除、插入等。awk则是更加强大的工具，它本身是一个完整的编程语言，可用于对数据的提取处理然后生成一些报表，主要针对类csv格式的文件。</p><h3><span id="正则表达式">正则表达式</span></h3><p>to be written</p><h3><span id="grep的种类">grep的种类</span></h3><ul><li><strong>grep</strong> | grep使用简单的模式和正则表达式进行搜索。</li><li><strong>egrep</strong> | egrep使用拓展版的正则表达式，包含更多的正则表达式功能。</li><li><strong>fgrep</strong> | fgrep是加速版的grep，主要适用于简单的模式匹配。</li><li><strong>zgrep, zegrep, zfgrep</strong> | 与grep, egrep, fgrep 效果相同，只是可以接受一个由compress或gzip压缩出来的压缩包进行搜索。在现在的操作系统中，多种的grep使用的是同一个binary，而不是不同的binary。比如说<code>grep -E</code>其实等效于egrep，<code>grep -F</code>等效于fgrep。</li></ul><h2><span id="常用参数">常用参数</span></h2><p><code>-A num, --after-context=num</code> - 打印出找到的匹配行后num行。这个跟<code>-B</code>，<code>-C</code>类似功能，主要用于查看上下文。</p><p><code>-B num, --before-context=num</code> - 打印出找到的匹配行前num行。</p><p><code>-C[num, --context=num]</code> - 打印出找到的匹配行前后num行，相当于<code>-A num -B num</code>。</p><p><code>-c, --count</code> - 统计出匹配的总行数，同一行有两个匹配也只算一行。</p><p><code>--colour=[when, --color=[when]]</code> - 将匹配的字符标记为彩色，when可以是’never’，‘auto’或’always’。</p><p><code>-e pattern, --regexp=pattern</code> - 制定在搜索中使用的匹配模式，多用于指定多个匹配模式的情况。</p><p><code>-H</code> - 在每一行前面打印出匹配的文件名，在多个文件的情况下这个是默认选项。</p><p><code>-h</code> - 在多个文件的情况下不打印出匹配的文件名。</p><p><code>-n</code> - 打印出匹配所在行的行数。</p><p><code>-i, --ignore-case</code> - 查找时忽略大小写。</p><p><code>-R, -r, --recursive</code> - 递归的去查找子目录下的文件。</p><p><code>-v, --invert-match</code> - 打印出不匹配的行。</p><p><code>-w, --word-regexp</code> - 只匹配整个单词。</p><h2><span id="案例学习">案例学习</span></h2><p>实验文件，随便找了一个莎士比亚的十四行诗：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat demofile</span><br><span class="line">sonnet 18</span><br><span class="line"></span><br><span class="line">Shall I compare thee to a summer&apos;s day? </span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">Rough winds do shake the darling buds of May, </span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line"></span><br><span class="line">Sometime too hot the eye of heaven shines, </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d </span><br><span class="line"></span><br><span class="line">But thy eternal summer shall not fade </span><br><span class="line">Nor lose possession of that fair thou owest; </span><br><span class="line">Nor shall Death brag thou wander&apos;st in his shade, </span><br><span class="line">When in eternal lines to time thou growest: </span><br><span class="line"></span><br><span class="line">So long as men can breathe or eyes can see, </span><br><span class="line">So long lives this and this gives life to thee.</span><br><span class="line">$ cp demofile demofile2</span><br></pre></td></tr></table></figure><ol><li><p>在文件中搜索某个字符串。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">Nor shall Death brag thou wander&apos;st in his shade, </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure></li><li><p>匹配整个单词。</p><p> 上面的例子中搜索and这个字符串匹配了wander这个单词，如果我们只想搜and这个单词可以使用<code>-w</code>参数。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -w &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure></li><li><p>忽略大小写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -i -w &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure></li><li><p>使用正则表达式</p><p> 只要把匹配的字符串换成需要的正则表达式即可。比如说需要搜索以And开头的行。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;^And&quot; demofile</span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines,</span><br></pre></td></tr></table></figure></li><li><p>显示上下文</p><p> 有时候搜出来需要看看上下文，可以利用上面提到的<code>-B</code>，<code>-A</code>和<code>-C</code>来实现。</p><p> 比如想要找出包含”nature”的句子并打印出上下两行。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -C2 &quot;nature&quot; demofile</span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d </span><br><span class="line"></span><br><span class="line">But thy eternal summer shall not fade</span><br></pre></td></tr></table></figure></li><li><p>统计出匹配的总行数</p><p> 比如说想要统计出现”to”的行数</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -c &quot;to&quot; demofile</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>如果想要统计出现的总次数的话，grep本身没有办法满足这个需求，需要使用sed或awk来实现。或者结合wc来实现。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -o &quot;to&quot; demofile| wc -l</span><br><span class="line">       5</span><br></pre></td></tr></table></figure></li><li><p>高亮匹配文字</p><p> 高亮匹配文字可以让肉眼可以第一时间的看到匹配结果，利用–color=auto/always来实现。此处nature高亮状。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep --color=auto &quot;nature&quot; demofile</span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d</span><br></pre></td></tr></table></figure></li><li><p>简单匹配多个模式</p><p> 查找多个字符串可以使用<code>|</code>字符来进行简单的匹配。比如说<code>&quot;heaven|nature&quot;</code>表示匹配heaven或者nature。因为这个是正则表达式的拓展部分，所以需要使用<code>-E</code>或者egrep。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -E &quot;heaven|nature&quot; demofile</span><br><span class="line">Sometime too hot the eye of heaven shines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d</span><br></pre></td></tr></table></figure></li><li><p>复杂匹配多个模式</p><p> 需要找出符合多个模式的匹配。比如说，找出以”When”开头或者包含”fade”的行。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; demofile</span><br><span class="line">But thy eternal summer shall not fade </span><br><span class="line">When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure></li><li><p>找出不满足条件的匹配</p><p>在一些情况下我们需要找出不满足某个条件的行，这个时候就可以用<code>-v</code>来实现了。</p><p>比如说想找出首字母不是大写字母的行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -v &quot;^[A-Z]&quot; demofile</span><br><span class="line">sonnet 18</span><br></pre></td></tr></table></figure></li><li><p>打印出匹配所在行的行数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; -n demofile</span><br><span class="line">13:But thy eternal summer shall not fade </span><br><span class="line">16:When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure></li><li><p>打印出文件名</p><p>进行多个文件搜索的情况下，默认会打印出文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; demofile demofile2</span><br><span class="line">demofile:But thy eternal summer shall not fade </span><br><span class="line">demofile:When in eternal lines to time thou growest: </span><br><span class="line">demofile2:But thy eternal summer shall not fade </span><br><span class="line">demofile2:When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure></li></ol><p>[EOF]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;背景知识&quot;&gt;背景知识&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;grep是linux中常用的文本处理的工具，与之类似的工具有sed和awk，它们分别适用于不同的场景。同时要想很好的使用grep等文本处理工具，需要对正则表达式有一定的了解。&lt;/p&gt;
&lt;h3&gt;&lt;span
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习 - mv, rm, mkdir</title>
    <link href="http://zhengyi.me/2016/06/03/learning-shell-rm-mv-mkdir/"/>
    <id>http://zhengyi.me/2016/06/03/learning-shell-rm-mv-mkdir/</id>
    <published>2016-06-03T14:25:48.000Z</published>
    <updated>2016-06-03T14:27:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="mv-move">mv （move）</span></h2><p>mv是用于移动文件的命令，mac下没有重命名的命令，所以很多时候mv也用来重命名文件。</p><p><strong>常用参数</strong></p><p><code>-f</code> - 强制覆盖不提醒<br><code>-i</code> - 覆盖目标文件前提醒<br><code>-n</code> - 不覆盖目标文件</p><p><strong>将n个文件移动到某个目录下</strong></p><p><code>mv file1 file2 file3 dir</code></p><p>如果目录不存在，会报错</p><p><strong>重命名/移动文件</strong></p><p><code>mv file1 file2</code></p><p>如果file2不存在则重命名为file2，如果存在则覆盖</p><p><strong>移动目录</strong></p><p><code>mv dir1 dir2</code></p><p>将dir1移动到dir2目录下，如果dir2不存在则是一个重命名的效果</p><h2><span id="rmremove">rm（remove）</span></h2><p>此命令用于删除文件和目录，与通配符结合使用时破坏很大，稍有不慎将酿成大错后悔莫及。</p><p>普通的删除只是将文件从文件系统中移除，磁盘上的那块空间并不会去动它。所以如果误删除的话，通过某一些还原工具是有可能找回来的。</p><blockquote><p>Linux并没有撤销删除命令，一旦你用<code>rm</code>命令将某个文件删除，你将很难恢复（mac可以通过特殊的数据还原工具）。如果错误的使用<code>rm</code>，特别是跟通配符结合使用的时候，将有可能造成极大的危害。<br>在<code>rm</code>中使用通配符之前，有一个有用的小诀窍：先将你的通配符用<code>ls</code>命令试试看，看一下所影响的文件。当你用<code>ls</code>测试过没问题以后，你可以直接把<code>ls</code>特换成<code>rm</code>。<sup><strong>[1]</strong></sup></p></blockquote><h3><span id="基本用法">基本用法</span></h3><p><code>rm [-dfiPRrvW] file ...</code></p><p><code>-f</code> - 强制删除，没有提示<br><code>-i</code> - 删除某个文件前请求确认<br><code>-P</code> - 粉碎性删除。删除文件前重新复写整个文件，往文件里不停写入<code>0xff</code>和<code>0x00</code>。这样删除的文件无法恢复。<br><code>-R</code> - 递归删除。如果指定的文件为目录，则删除目录下所有的文件及其子目录。</p><h2><span id="rmdirremove-directory">rmdir（remove directory）</span></h2><p>不要被这货的名字迷惑了，这个命令唯一的用途就是删除一个空白的文件夹。如果文件夹非空还是要用<code>rm -r</code>来删除，不知道它存在的意义是什么。</p><h2><span id="mkdirmake-directory">mkdir（make directory）</span></h2><p>顾名思义，创建文件夹使用。</p><h3><span id="基本用法">基本用法</span></h3><p><code>-p</code> 创建中间目录，比如<code>mkdir /path/with/many/layer</code>会帮你吧layer之前的所有层级的目录都创建出来。<br><code>-m</code> 制定文件夹的权限，详见chmod。</p><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="http://linuxcommand.org/lc3_lts0050.php" target="_blank" rel="external">Manipulating Files</a></li></ol><p><strong>阅读更多</strong></p><a href="/2016/05/23/learning-shell-in-mac/" title="Mac/Linux 命令学习">Mac/Linux 命令学习</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;mv-move&quot;&gt;mv （move）&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;mv是用于移动文件的命令，mac下没有重命名的命令，所以很多时候mv也用来重命名文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-f&lt;/cod
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习 - chflags</title>
    <link href="http://zhengyi.me/2016/06/02/learning-shell-chflags/"/>
    <id>http://zhengyi.me/2016/06/02/learning-shell-chflags/</id>
    <published>2016-06-02T15:20:25.000Z</published>
    <updated>2016-06-02T15:32:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="背景知识">背景知识</span></h2><p>在<a href="/2016/05/24/learning-shell-in-mac-ls/" title="ls">ls</a>命令中有出现过一个<code>-O</code>的选项，即列出文件的file flag。这个File flag所为何物？</p><p>File flag是在BSD Unix中的概念，跟Linux系统中的attr是差不多的一个概念，是文件的一些标志位来存放文件的某些属性。chflags就是来修改这个file flag的。这个文件属性是跟文件系统相关的，所以这个命令在不同的文件系统上的支持程度不一样，体现在某一些flag在一些特定的文件系统上没有。<sup>[1]</sup></p><p>所有的属性都可以被超级管理员修改，有一些可以被文件的所有者修改。以下列出比较常用的几个属性<sup>[1]</sup>。</p><table><thead><tr><th>属性</th><th>ls中显示</th><th>chflags中使用</th><th>文件所有者能否修改？</th><th>详述</th></tr></thead><tbody><tr><td>隐藏</td><td>hidden</td><td>hidden</td><td>能</td><td>设置以后在GUI上看不到，ls依然可以看到d</td></tr><tr><td>系统级只能添加</td><td>sappnd</td><td>sappnd, sappend</td><td>否</td><td>设置以后此文件不能够截断或者复写(overwrite)，只能通过append模式添加内容</td></tr><tr><td>用户级只能添加</td><td>uappnd</td><td>uappnd, uappend</td><td>能</td><td>设置以后此文件不能够截断或者复写(overwrite)，只能通过append模式添加内容</td></tr><tr><td>系统级只读</td><td>schg</td><td>schg, schange, simmutable</td><td>否</td><td>不能够重命名、移动、删除、更改内容</td></tr><tr><td>用户级只读</td><td>uchg</td><td>uchg, uchange, uimmutable</td><td>能</td><td>不能够更改内容</td></tr></tbody></table><h2><span id="基本用法">基本用法</span></h2><p><code>chflags [-fhv] [-R [-H | -L | -P]] flags file</code></p><h2><span id="常用参数">常用参数</span></h2><p><code>-R</code> 递归修改参数中文件夹下面的所有文件和文件夹的属性</p><h2><span id="具体案例">具体案例</span></h2><p><strong>为一个文件添加一个属性</strong></p><p><code>chflags uchg file</code></p><p><strong>为一个文件删除一个属性</strong></p><p><code>chflags nouchg file</code></p><p>在属性名字前面添加no就可以将属性删除，如果这个属性本身已no开头（比如nodump）则去掉no。</p><p><strong>将文件夹及其文件夹下所有文件属性进行修改</strong></p><p><code>chflags -R uchg directory</code></p><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="https://en.wikipedia.org/wiki/Chattr" target="_blank" rel="external">chattr - Wikipedia</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;背景知识&quot;&gt;背景知识&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;/2016/05/24/learning-shell-in-mac-ls/&quot; title=&quot;ls&quot;&gt;ls&lt;/a&gt;命令中有出现过一个&lt;code&gt;-O&lt;/code&gt;的选项，即列出文件的f
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习 - cd, pwd, pushd, popd</title>
    <link href="http://zhengyi.me/2016/06/02/learning-shell-cd-pwd-pushd-popd/"/>
    <id>http://zhengyi.me/2016/06/02/learning-shell-cd-pwd-pushd-popd/</id>
    <published>2016-06-02T13:43:06.000Z</published>
    <updated>2016-06-02T13:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="cd-change-directory">cd (change directory)</span></h2><p><strong>切换到某个目录</strong></p><p><code>cd /to/path</code></p><p><strong>回到用户主目录</strong></p><p><code>cd</code></p><p><strong>返回前一个目录</strong></p><p>只会记录一个前一个目录的记录，并不会记录所有的记录。</p><p><code>cd -</code></p><h2><span id="pwd-present-working-directory">pwd (present working directory)</span></h2><p>查看当前目录</p><h2><span id="pushd-amp-popd-push-to-directory-pop-back">pushd &amp; popd (push to directory, pop back)</span></h2><p><code>cd</code>有一个缺点就是它无法保存导航的记录，如果切换到某几个文件夹之后想回到之前的路径就有点困难。特别是在写某一些脚本的时候，切换到某个目录下执行一些任务以后希望能够回到之前的目录。</p><p><code>pushd</code>可以很简单的解决这个问题。<code>pushd</code>命令将导航的历史记录利用栈的数据结构进行存储，可以push n层目录，然后逐级的pop出来。</p><p><strong>push到某个目录</strong></p><p><code>pushd /to/path</code></p><p><strong>pop会导航栈中上一个目录</strong></p><p><code>popd</code></p><p><strong>交换栈上最上面的两个路劲</strong></p><p><code>pushd</code></p><p><strong>旋转导航栈</strong><sup>[1]</sup></p><p><code>pushd +2</code></p><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="https://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29" target="_blank" rel="external">Stack Wikipedia</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;cd-change-directory&quot;&gt;cd (change directory)&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;切换到某个目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd /to/path&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;stro
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习 - 标准输入输出重定向</title>
    <link href="http://zhengyi.me/2016/05/31/unix-standard-input-output-redirection/"/>
    <id>http://zhengyi.me/2016/05/31/unix-standard-input-output-redirection/</id>
    <published>2016-05-31T15:00:02.000Z</published>
    <updated>2016-06-03T14:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="预备知识">预备知识</span></h2><h3><span id="文件描述符-file-descriptor">文件描述符( File Descriptor )</span></h3><p>在Unix 系统中文件描述符是用于访问文件、输入输出、管道、网络套接字的一个抽象概念<sup>[3]</sup>。文件描述符是一个非负的正整数，每一个Unix进程中都会有三个与<a href="https://www.wikiwand.com/en/Standard_streams" target="_blank" rel="external">标准流</a>所对应的的POSIX文件描述符，分别为：</p><ol><li><code>stdin</code> - 标准输入，提供给应用的标准输入。文件描述符为<strong>0</strong>。</li><li><code>stdout</code> - 标准输出，程序的输出，在非重定向的情况下为终端。文件描述符为<strong>1</strong>。</li><li><code>stderr</code> - 标准错误输出，程序的错误输出。文件描述符为<strong>2</strong>。</li></ol><p>关于文件描述符的详细，见文章</p><h2><span id="输出重定向">输出重定向</span></h2><p>有两种方式可以将输出重定向：</p><ul><li><p><strong>n</strong>&gt; file<br>将文件描述符n重定向到文件file中，如果文件不存在则会创建文件，如果存在的话将会覆盖原有内容。</p></li><li><p><strong>n</strong>&gt;&gt; file<br>将文件描述符n重定向到文件file中，如果文件不存在将会创建文件，如果存在则会在文件的结尾开始写入输出。</p></li></ul><p>如果我们没有指定文件描述符，则默认为1，即标准输出。</p><h3><span id="重定向到不同的文件">重定向到不同的文件</span></h3><p>我们可以把<code>stdout</code>和<code>stderr</code>输出到不同的文件，例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zhengyi$ ls</span><br><span class="line">file1 file2 file3</span><br><span class="line">zhengyi$ ls f* e* 1&gt;out.txt 2&gt;err.txt</span><br><span class="line">zhengyi$ cat out.txt </span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">file3</span><br><span class="line">zhengyi$ cat err.txt </span><br><span class="line">ls: e*: No such file or directory</span><br></pre></td></tr></table></figure><h3><span id="重定向到一个文件">重定向到一个文件</span></h3><p>很多情况下我们需要将<code>stdout</code>和<code>stderr</code>输出到同一个文件中，这个时候我们可以使用 <code>&amp;&gt;</code> or <code>&amp;&gt;&gt;</code>，它们会把标准输出和标准错误输出到一起。</p><p>另外一种方法是利用<code>m&gt;&amp;n</code>，将某一个输出重定向到另一个输出中来。这个时候需要注意的是使用它们的顺序，比如下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zhengyi$ ls f* z* 1&gt;out.txt 2&gt;&amp;1</span><br><span class="line">zhengyi$ cat out.txt </span><br><span class="line">ls: z*: No such file or directory</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">file3</span><br><span class="line">zhengyi$ ls f* z* 2&gt;&amp;1 1&gt;out.txt </span><br><span class="line">ls: z*: No such file or directory</span><br><span class="line">zhengyi$ cat out.txt </span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">file3</span><br></pre></td></tr></table></figure></p><p><code>ls f* z* 1&gt;out.txt 2&gt;&amp;1</code>这个例子是先将标准输出重定向到文件out.txt中，然后将标准错误重定向到标准输出中，这个是可以工作的。<code>ls f* z* 2&gt;&amp;1 1&gt;out.txt</code>这个例子中，先将标准错误重定向到了标准输入，这个时候的标准输入指向的是默认的标准输入，而当后面将标准输入重定向到文件out.txt时，并不会改变标准错误的输出目标。</p><h3><span id="忽略某一些输出">忽略某一些输出</span></h3><p>比如说我们想要过滤输出中的错误，那么我们可以将标准错误输出到<code>/dev/null</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zhengyi$ ls f* z*</span><br><span class="line">ls: z*: No such file or directory</span><br><span class="line">file1 file2 file3</span><br><span class="line">zhengyi$ ls f* z* 2&gt;/dev/null </span><br><span class="line">file1 file2 file3</span><br></pre></td></tr></table></figure><h2><span id="输入重定向">输入重定向</span></h2><p>与输出重定向相反，输入重定向是利用”&lt;”符号来表达的。例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">zhengyi$ cat out.txt </span><br><span class="line">err.txt</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">file3</span><br><span class="line">out.txt</span><br><span class="line">zhengyi$ sort -r &lt; out.txt </span><br><span class="line">out.txt</span><br><span class="line">file3</span><br><span class="line">file2</span><br><span class="line">file1</span><br><span class="line">err.txt</span><br></pre></td></tr></table></figure><p>输出重定向可以和输入重定向组合起来一起使用，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhengyi$ sort -r &lt; out.txt &gt; sorted.txt</span><br></pre></td></tr></table></figure><p>这个是将out.txt作为输入，然后把sort的结果重定向到sorted.txt中。同时使用输入和输出重定向的时候需要注意一点就是尽量避免使用同一个文件。比如说上面这个sort的例子，如果指向同一个文件，那么一开始输出重定向会先把out.txt文件清空。</p><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="http://www.ibm.com/developerworks/library/l-lpic1-v3-103-4/l-lpic1-v3-103-4-pdf.pdf" target="_blank" rel="external">Learn Linux, 101: Streams, pipes, and redirects</a></li><li><a href="http://linuxcommand.org/lc3_lts0070.php" target="_blank" rel="external">I/O Redirection</a></li><li><a href="https://www.wikiwand.com/en/File_descriptor" target="_blank" rel="external">Wikipedia - File Descriptor</a></li></ol><p><strong>阅读更多</strong></p><a href="/2016/05/23/learning-shell-in-mac/" title="Mac/Linux 命令学习">Mac/Linux 命令学习</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;预备知识&quot;&gt;预备知识&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;文件描述符-file-descriptor&quot;&gt;文件描述符( File Descriptor )&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在Unix 系统中文件描述符是用于访问文件、输入输出、管
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
      <category term="linux" scheme="http://zhengyi.me/tags/linux/"/>
    
      <category term="操作系统" scheme="http://zhengyi.me/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习-每日一贴之cat</title>
    <link href="http://zhengyi.me/2016/05/30/learning-shell-in-mac-cat/"/>
    <id>http://zhengyi.me/2016/05/30/learning-shell-in-mac-cat/</id>
    <published>2016-05-30T15:05:40.000Z</published>
    <updated>2016-05-31T15:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="基本">基本</span></h2><p>cat基本用途是把指定文件读取出来，并输出到STDOUT中。</p><p><code>cat [-benstuv] [file ...]</code></p><h2><span id="常用功能">常用功能</span></h2><p><code>-b</code> 打印出行数，不包含空白行，从1开始<br><code>-n</code> 打印出行数，包括空白航，从1开始<br><code>-e</code> 显示不能打印的字符，每行结尾打印<code>$</code>符号<br><code>-t</code> 显示不能打印的字符，制表符显示为<code>^I</code></p><h2><span id="使用场景">使用场景</span></h2><p><strong>打印一个文件到终端来查看其中内容</strong></p><p><code>cat file</code></p><p><strong>打印文件到另一个文件中</strong></p><p><code>cat file1 &gt; file2</code></p><p><strong>打印文件到另一个文件结尾</strong></p><p><code>cat file1 &gt;&gt; file2</code></p><p>参考<a href="/2016/05/31/unix-standard-input-output-redirection/" title="输入输出重定向">输入输出重定向</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;基本&quot;&gt;基本&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;cat基本用途是把指定文件读取出来，并输出到STDOUT中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cat [-benstuv] [file ...]&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;常用功能&quot;&gt;常用功能
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>《非洲三万里》读书笔记</title>
    <link href="http://zhengyi.me/2016/05/28/africa-30-kilo-metre-reading-note/"/>
    <id>http://zhengyi.me/2016/05/28/africa-30-kilo-metre-reading-note/</id>
    <published>2016-05-28T12:16:36.000Z</published>
    <updated>2016-06-02T13:51:55.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img3.doubanio.com/lpic/s28383445.jpg" alt="非洲三万里-封面"></p><h2><span id="书评">书评</span></h2><p>毕淑敏对于我来说是一个既熟悉又陌生的作家，熟悉是因为在初高中的时候语文老师经常会将其散文、短文给我们当做阅读材料。陌生呢，是因为我记不起来任何一篇她的作品，也没有主动地去读过她任何一本书。非洲加上毕淑敏，这个组合吸引了我去阅读这本书，我想看看一位作家是如何写她的游记的。</p><a id="more"></a><p>本书用28篇短文记录了作者从南非出发乘坐“非洲之傲”火车一路到坦桑尼亚，然后转站埃塞俄比亚的所见、所观、所感。每篇短文之间并没有太多的关联，而是针对某个目的地过着某个故事所写的。所以阅读的时候我并没有从头至尾的顺序进行阅读，而是看着标题根据自己的喜好跳着阅读。由于作者以及这段行程的原因，我认为这本书有以下三个特点：</p><ol><li>文笔很好，对于一些细节的描述非常细腻。文中很对地方对于景色、人物的描写非常的细腻，可以感受到作者深厚的文学功底。关于很多景色，读者可以透过作者的描写想象出一个生动的场景，而不是像很多书中直接上照片那样的粗暴。</li><li>很多的历史科普，较少的亲身经历。文中你会经常看到大段大段的历史介绍，我觉得这并没有什么不好。因为这对于像我这种不了解非洲历史的读者来说确实是一种科普。但是由于作者的整个行程主要是去参观了一些比较著名的景点，总让人感觉缺少了一份真实感。</li><li>作者所接触的非洲其实只是很小的一部分，而且大多数行程都是旅行社所安排，不见得看到的就是真实的非洲。所以书中有一些观点可能略有偏颇。</li></ol><p>虽然作者在介绍一些历史知识的时候我确实饶有兴致的去阅读着，但是这本书我最喜欢的部分却是关于“非洲之傲”上的人和事。如果作者这本书的28篇短文是讲关于“非洲之傲”上面28个的故事的话，我觉得会是更有趣的一本书。</p><p>一句话概括这本书：<strong>这是一本文笔很好且有很多历史科普的非洲游记，但缺乏特点</strong>。</p><h2><span id="对我的启发">对我的启发</span></h2><p>作者以一种很“认真”的方式进行着旅游，她对于所要去的地方都会提前做足功课去了解其历史。并且在游览的时候也会认真的去听取导游关于景点的历史介绍，同时又会对于这些历史现象结合现状做出自己的思考。这一套“认真”旅游的方法是我们现在很多人所欠缺的。</p><p>我们对于旅游的目的地往往关注的是有什么好玩的，好吃的，好看的，然后买买买。回来以后对于那个去过的地方的印象似乎跟大众对于它的评价没什么区别，对于它的历史也基本没有更深入的了解。很惭愧，我觉得我就是这样子的，对于去过的很对地方都缺乏这种认真的态度。没有更多的去了解当地的历史，认真的对它的现状进行思考，认真得去跟当地人沟通。</p><p><br></p><hr><p><strong><em>非洲之傲的路线图</em></strong></p><p><img src="/img/pride_of_Africa.png" alt="非洲之傲"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img3.doubanio.com/lpic/s28383445.jpg&quot; alt=&quot;非洲三万里-封面&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;书评&quot;&gt;&lt;a href=&quot;#书评&quot; class=&quot;headerlink&quot; title=&quot;书评&quot;&gt;&lt;/a&gt;书评&lt;/h2&gt;&lt;p&gt;毕淑敏对于我来说是一个既熟悉又陌生的作家，熟悉是因为在初高中的时候语文老师经常会将其散文、短文给我们当做阅读材料。陌生呢，是因为我记不起来任何一篇她的作品，也没有主动地去读过她任何一本书。非洲加上毕淑敏，这个组合吸引了我去阅读这本书，我想看看一位作家是如何写她的游记的。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://zhengyi.me/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="http://zhengyi.me/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="非洲" scheme="http://zhengyi.me/tags/%E9%9D%9E%E6%B4%B2/"/>
    
      <category term="旅行" scheme="http://zhengyi.me/tags/%E6%97%85%E8%A1%8C/"/>
    
      <category term="毕淑敏" scheme="http://zhengyi.me/tags/%E6%AF%95%E6%B7%91%E6%95%8F/"/>
    
  </entry>
  
  <entry>
    <title>“知行合一”</title>
    <link href="http://zhengyi.me/2016/05/27/unity-of-knowlede-and-action/"/>
    <id>http://zhengyi.me/2016/05/27/unity-of-knowlede-and-action/</id>
    <published>2016-05-27T12:50:23.000Z</published>
    <updated>2016-05-28T13:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>知识对于一个人有三种状态，不知道的，知道的，做到的。本文不讨论不知道的情况。</p><p><img src="/img/know_vs_action.png" alt="知行合一"></p><p>我认为大多数的知识停留在知道这个层面。我们可以通过很多途径学习、吸收知识，但是我们在做一件事情的时候，驱动我们的不是这些知识，而是习惯和潜意识。比如说学打羽毛球，一个新手通过看视频、看动作要领等学习到了很多关于打羽毛球的要领，但是这跟打好羽毛球其实并没有直接的关系。只能说掌握了这些知识可能能让你学打羽毛球的过程变得简单一些，等你最终学会了打羽毛球的时候，你脑子里想的绝对不是动作要领，因为这些复杂的动作已经转化成你脑子里的一个memory chunk。所以从小到大从书本上学到了很多大道理，知道了很多励志的故事，但绝大多数仅仅只是停留在知道的层面上。</p><p>我们做一件事情的时候，很多时候是带着一种惯性去做的。一个在某一方面很牛逼的人，你如果问他你为什么这么牛？他可能会跟你说出很多点，但是这并不意味着你知道了这些点你就能成为跟他一样的人。一是因为你觉的很牛逼事情，在他看来可能只是一件随随便便就能做到的事情，他背后包含的是他长期以来形成的惯性。而他给出的一些点往往只是他做出来的一个不完全的总结，你不可能完全重复他的成长轨迹。</p><p>往往越高层次的人给出的一些建议约精炼。如果你问你的manager让他给你一些建议，他可能会跟你说一堆如果在工作中做好的一些技巧。如果你问你们公司老板，他可能会跟你说一些人生小建议，而不涉及到一些具体的东西。而如果你去问乔布斯，他可能就跟你说一句话，“Stay Hungry Stay Foolish”。</p><p>从知道到做到是有一个巨大的鸿沟的，而从做到到知道往往只有咫尺之遥。</p><p>那是不是说知道这个层面就不重要呢？并不然。我们的行为系统是需要知识系统支撑的，如果你什么都不知道你能做的事情其实很少。我们需要做的就是尽可能的把我们知道的内化成我们自己的一部分，融入到我们的行为当中。届时，即使你可以把所有的技巧知识都忘了，你依然可能随时从你的大脑深处召唤出来。这就像倚天屠龙记里面张三丰教张无忌太极剑法，教完问其记得么？当张无忌说全忘了的时候，也就是他全部融会贯通的时候。</p><p>纵然我们没有张无忌这般天赋异禀，但我们也可以通过多练习和思考慢慢的去忘掉那些讨人厌的各种技巧、各种道理。 我觉得可以通过以下几种方法进行修炼：</p><ol><li>当你在做一件你需要提高的事情的时候，给自己提一些更高的要求，并尽可能的去思考如何才能做得更好。可以观察自身的一些特点习惯中找到进步的点，也可以尽可能的去回想你所知道的知识中有哪一些可以帮助你提高。</li><li>在做的过程中，以及做完之后要经常的用一个“上帝视角”看看你做的事情。有哪些做的不好？为什么做不好？是因为旧的习惯还是说某些知识的缺乏。</li><li>通过阅读等方法拓宽自己知识体系，并积极将其跟自己的实践结合起来思考。如果你在下一次做这个事情的时候能够注意到这个点这就够了。何况这样可以让我们站在前人的肩膀上，为什么不呢？</li></ol><p>我不知道王阳明当时提出“知行合一”的原意是什么，但是我理解的“知行合一”是通过行动将你知道的和你能做到的进行统一，从而达到一个”忘记”的境界。</p><p>[end]</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识对于一个人有三种状态，不知道的，知道的，做到的。本文不讨论不知道的情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/know_vs_action.png&quot; alt=&quot;知行合一&quot;&gt;&lt;/p&gt;
&lt;p&gt;我认为大多数的知识停留在知道这个层面。我们可以通过很多途径学习、吸收知识，
      
    
    </summary>
    
      <category term="思考讨论" scheme="http://zhengyi.me/categories/%E6%80%9D%E8%80%83%E8%AE%A8%E8%AE%BA/"/>
    
    
      <category term="思考" scheme="http://zhengyi.me/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="行动" scheme="http://zhengyi.me/tags/%E8%A1%8C%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习-每日一贴之cp</title>
    <link href="http://zhengyi.me/2016/05/25/learning-shell-in-mac-cp/"/>
    <id>http://zhengyi.me/2016/05/25/learning-shell-in-mac-cp/</id>
    <published>2016-05-25T13:53:30.000Z</published>
    <updated>2016-05-25T14:19:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="相关概念">相关概念</span></h2><h3><span id="symbolic-links">Symbolic links</span></h3><p>Symbolic links/soft links可以<anchor>理解成为一个快捷方式</anchor>，跟mac GUI右击出来的alias有着很类似的功能，但是比alias要更加的底层一些。Softlink 即可以针对文件也可以针对文件夹进行创建。</p><p>通过<code>ln  -s target/file/or/dir link/path</code>来创建。我创建了针对文件和文件夹的softlink和alias，通过命令可以观察它们之间的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ls -lo@</span><br><span class="line">total 3024</span><br><span class="line">-rwxr-xr-x  1 zhengyi    2723 May 24 08:20 build.sh</span><br><span class="line">-rw-r--r--@ 1 zhengyi  257136 May 25 20:49 build.sh.alias</span><br><span class="line">com.apple.FinderInfo     32 </span><br><span class="line">lrwxr-xr-x  1 zhengyi       8 May 25 20:49 build.sh.link -&gt; build.sh</span><br><span class="line">drwxr-xr-x  9 zhengyi     306 May 25 20:24 src</span><br><span class="line">-rw-r--r--@ 1 zhengyi 1268908 May 25 20:40 src_alias</span><br><span class="line">com.apple.FinderInfo     32 </span><br><span class="line">lrwxr-xr-x  1 zhengyi       4 May 25 20:39 src_link -&gt; src/</span><br></pre></td></tr></table></figure><p>我们可以看到softlink是通过文件信息来识别的，而alias是通过拓展属性来进行实现的，也就是说alias只有在apple 的Finder下有用，在其他地方他就是一个普通的文件。    </p><p>如果我们链接到一个目录的话，alias因为是一个文件自然不能够cd进去，而softlink是可以cd进去的。</p><h3><span id="hard-link">Hard link</span></h3><p>与softlink相对应，与softlink不同，hardlink不是一个“快捷方式”，而是一个真实存在的文件。文件可以理解成磁盘上一块内存，而我们在终端和GUI看到的“文件”只是指向了那块内存，所以我们可以有多个”文件”指向同一块内存。这就是hardlink干的事情。hardlink是不允许针对一个目录创建的，因为这样会破坏文件系统的结构。</p><h2><span id="常用参数">常用参数</span></h2><p><code>-f</code> - 将覆盖目标文件，并不做提示。<br><code>-n</code> - 不覆盖目标文件。<br><code>-r</code> - 这个是<anchor>历史版本的递归拷贝</anchor>，不推荐使用。<br><code>-R</code> - 如果源文件是一个目录的话，递归拷贝到目标路径。如果源文件以<code>/</code>结尾，那么源文件夹里的内容将被拷贝到目标路径，如果不指定则是拷贝整个文件夹。<br><code>-H</code> - 与<code>-R</code>配合使用，保持原有的softlink。<br><code>-P</code> - 与<code>-R</code>配合使用，不保持原有的softlink，这个是递归拷贝的时候默认的选项。<br><code>-v</code> - 与<code>-R</code>配合使用，打印出所有被拷贝的文件。<br><code>-p</code> - 将保护原始文件的修改时间、访问时间、flie flag，文件模式等信息。</p><h2><span id="具体场景">具体场景</span></h2><p><strong>拷贝单个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1.txt ../file2.txt</span><br></pre></td></tr></table></figure><p><strong>拷贝多个文件</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1.txt file2.cpp file3.cs test/src</span><br></pre></td></tr></table></figure><p><strong>拷贝符合某个文件名规则的文件</strong></p><p>cp支持简单的通配符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *.zip package</span><br></pre></td></tr></table></figure><p><strong>拷贝整个目录，包括子目录，并维持文件的修改时间不变</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -RpH dir1 dir2/src</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;相关概念&quot;&gt;相关概念&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span id=&quot;symbolic-links&quot;&gt;Symbolic links&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;Symbolic links/soft links可以&lt;anchor&gt;理解成为一个快捷方式
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac 命令学习-每日一贴之ls</title>
    <link href="http://zhengyi.me/2016/05/24/learning-shell-in-mac-ls/"/>
    <id>http://zhengyi.me/2016/05/24/learning-shell-in-mac-ls/</id>
    <published>2016-05-24T12:53:30.000Z</published>
    <updated>2016-06-03T14:28:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="基本用法">基本用法</span></h2><p><code>ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]</code></p><p>ls 后面可以跟0~N个参数，最后可以跟0~N个文件名。</p><p>文件名支持通配符，可以进行简单的文件名搜索。如果匹配到目录的话，会将目录中的子项目一同打印出来。</p><h2><span id="相关概念">相关概念</span></h2><h3><span id="通配符规则">通配符规则</span></h3><p><strong>* （星号通配符）</strong></p><p>匹配0~N个任意字符。</p><p> <strong>?（问号通配符）</strong></p><p>匹配1个任意unicode字符。</p><p><strong>[char] （方括号通配符）</strong></p><p>匹配1个方括号内任意的一个字符。</p><p>括号中的字母可以使用POSIX 字符集（POSIX Character Classes），包含以下几种。我只列出了认为比较常用的，详见<a href="http://man7.org/linux/man-pages/man7/glob.7.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man7/glob.7.html</a></p><table><thead><tr><th>表达式</th><th>解释</th></tr></thead><tbody><tr><td><code>[a-z]</code></td><td>小写a到z</td></tr><tr><td><code>[A-Z]</code></td><td>大写a到z</td></tr><tr><td><code>[0-9]</code></td><td>数字0到9</td></tr><tr><td><code>[:alnum:]</code></td><td>Alphanumeric字符，表示拉丁文和阿拉伯数字<sup>[4]</sup></td></tr><tr><td><code>[:alpha:]</code></td><td>Alphabetic characters，拉丁文</td></tr><tr><td><code>[:digit:]</code></td><td>数字</td></tr><tr><td><code>[:upper:]</code></td><td>大写的拉丁文</td></tr><tr><td><code>[:lower:]</code></td><td>小写的拉丁文</td></tr><tr><td><code>[:blank:]</code></td><td>ASCII 空格或制表符</td></tr><tr><td><code>[:space:]</code></td><td>ASCII 空格</td></tr></tbody></table><p>使用方法</p><p><code>[[:alpha:]]*</code>，匹配以字母开头的字符串。</p><p><strong>[!char]（方括号通配符）</strong></p><p>通过在第一位加<code>!</code>表示匹配不包含方括号之内的字符</p><h2><span id="常用功能">常用功能</span></h2><p><code>-A</code> - 列出目录下除了<code>.</code>和<code>..</code>以外的所有文件。<br><code>-a</code> - 列出目录下所有文件，包括目录以<code>.</code>开头的文件。<br><code>-d</code> - 仅打印出目录名字，不去打印内部的文件。<br><code>-l</code> - 打印长格式，包含<br><code>-G</code> - 彩色输出。<br><code>-p</code> - 如果为目录，在显示名称后面打印一个’/‘<br><code>-r</code> - 根据目前输出默认的排序逆序。<br><code>-O</code> - 打印出File Flag</p><p><strong>长格式</strong></p><pre><code>I            II  III      IV       V  VI           VIIdrwxr-xr-x   9   zhengyi  group   306 May 24 08:24 .drwxr-xr-x  42   zhengyi  group  1428 May 23 23:20 ..-rw-r--r--@  1   zhengyi  group  6148 May 24 08:24 .DS_Store-rwxr-xr-x   1   zhengyi  group  2723 May 24 08:20 build.sh-rw-r--r--   1   zhengyi  group   883 May 24 08:19 db.json-rw-r--r--   1   zhengyi  group  2281 May 24 08:20 gen.pydrwxr-xr-x   2   zhengyi  group    68 May 24 08:18 libdrwxr-xr-x   7   zhengyi  group   238 May 24 08:25 srcdrwxr-xr-x   4   zhengyi  group   136 May 24 08:18 tests</code></pre><p>I：文件权限信息，详见下图。如果有<code>@</code>符号，表示这个文件有一些拓展属性，可以通过添加<code>-@</code>参数查阅，也可以使用xattr工具来查看具体信息<sup>[1]</sup>。<br>II：链接计数（link count），包括<em>hard links</em>，<em>symbolic links</em>，还有目录引用。当前目录的<code>.</code>会引用自己，同时它的所有的子目录都会持有一个<code>..</code>指向当前目录。这就导致了目录的链接计数往往比较大。<br>III：owner name<br>IV：owner group<br>V：文件大小，单位为字节<br>VI：最后修改日期<br>VII：文件名</p><p>Access right in the first column<br><img src="http://linuxcommand.org/images/permissions_diagram.gif" alt=""><sup>[2]</sup></p><h2><span id="具体案例">具体案例</span></h2><p><strong>设置默认的别名（alias）</strong></p><p>个人喜好将输出搞的彩色一点，比较明显能看出文件的类别</p><p><code>alias ls=&#39;ls -G&#39;</code></p><p><strong>列出文件夹下所有的子文件夹</strong></p><p><code>ls -d */</code></p><p><strong>按照最后修改时间排序</strong></p><p><code>ls -l -t -T (新修改的在前)</code><br><code>ls -l -t -T -r（老修改的在前）</code></p><p><strong>根据文件大小排序</strong></p><p><code>ls -l -S （从大到小）</code></p><h2><span id="参考资料">参考资料</span></h2><ol><li><a href="http://mackuba.eu/2008/06/30/ls-on-mac-and-extended-file-attributes/" target="_blank" rel="external">“ls” on Mac and extended file attributes</a></li><li><a href="http://linuxcommand.org/images/permissions_diagram.gif" target="_blank" rel="external">permission gif</a></li><li><a href="http://www.linfo.org/wildcard.html" target="_blank" rel="external">Wildcard - 1</a></li><li><a href="http://linuxcommand.org/lc3_lts0050.php" target="_blank" rel="external">Wildcard - 2</a></li><li><a href="https://en.wikipedia.org/wiki/Alphanumeric" target="_blank" rel="external">Alphanumeric - Wikipedia</a></li></ol><p><strong>阅读更多</strong></p><a href="/2016/05/23/learning-shell-in-mac/" title="Mac/Linux 命令学习">Mac/Linux 命令学习</a>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;基本用法&quot;&gt;基本用法&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1] [file ...]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ls 后面可以跟0~N个参数，最后可以跟0~N个文
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>Mac/Linux 命令学习</title>
    <link href="http://zhengyi.me/2016/05/23/learning-shell-in-mac/"/>
    <id>http://zhengyi.me/2016/05/23/learning-shell-in-mac/</id>
    <published>2016-05-23T14:53:35.000Z</published>
    <updated>2016-06-06T13:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="干嘛要学命令">干嘛要学命令</span></h2><p>切换到mac下工作有一段时间了，难免要在终端中做一下操作，目前掌握的一些比较简单的命令行有时已经难以驾驭一些比较复杂的操作了。有必要系统得过一遍主要的一些命令。</p><p>除了装逼意外，命令行还在有很多好处：</p><ol><li>打字的速度和准确性远远高于鼠标，频繁的切换鼠标和键盘是一件挺麻烦的事情。</li><li>命令行可以写成脚本自动化一些操作，懒人的福音。</li><li>在一些服务器的环境下只能使用命令行。</li></ol><h2><span id="如何学命令">如何学命令</span></h2><p>Learning by doing 是最好的方式，特别是对这种实用性的东西，不动动手是绝对不行的。我觉得学习命令行比较好的方式是：</p><ol><li>通读一遍man，知道一个命令能够做的事情，即使记不住也没关系，至少知道可以做，等需要的时候再看具体的细节也不迟。终端下的man不方便阅读的话可以通过Dash等工具来阅读。</li><li>对于平时可能用到的，自己动手敲一遍看看效果。</li><li>设想几个可能比较常用的场景，然后利用命令来完成这些任务。以后碰到这几个场景的时候可以查阅回忆。</li></ol><p>第三点其实是借鉴了<a href="https://github.com/tldr-pages/tldr" target="_blank" rel="external">tldr</a>（too long don’t read）具，可以理解成是一个简化版的man。</p><p>Mac 10.3+ 系统下默认的shell是bash<sup>[1]</sup>，大部分命令的效果和linux下面相同，某一些命令的具体参数和行为有所差异。</p><h2><span id="小技巧">小技巧</span></h2><h2><span id="每日一贴">每日一贴</span></h2><h3><span id="目录操作">目录操作</span></h3><ul><li><a href="/2016/05/24/learning-shell-in-mac-ls/" title="ls">ls</a>  - <em>2016年5月24号</em></li><li><a href="/2016/06/02/learning-shell-cd-pwd-pushd-popd/" title="cat,pushd,popd">cat,pushd,popd</a> - <em>2016年6月2号</em></li></ul><h3><span id="文件操作">文件操作</span></h3><ul><li><a href="/2016/05/25/learning-shell-in-mac-cp/" title="cp">cp</a>  - <em>2016年5月25号</em></li><li><a href="/2016/05/24/learning-shell-in-mac-ls/" title="cat">cat</a>  - <em>2016年5月30号</em></li><li><a href="/2016/06/02/learning-shell-chflags/" title="chflags">chflags</a> - <em>2016年6月2号</em></li><li>ln</li><li><a href="/2016/06/03/learning-shell-rm-mv-mkdir/" title="rm,mv,mkdir">rm,mv,mkdir</a> - <em>2016年6月3号</em></li><li>find</li></ul><h3><span id="文本操作过滤器">文本操作/过滤器</span></h3><ul><li>sort</li><li>uniq</li><li><a href="/2016/06/06/learning-shell-grep/" title="grep">grep</a> - <em>2016年6月6号</em></li><li>fmt</li><li>pr</li><li>head</li><li>tail</li><li>tr</li><li>sed</li><li>awk</li></ul><h3><span id="调试">调试</span></h3><ul><li>dtruss</li></ul><h3><span id="其他">其他</span></h3><ul><li>xargs</li></ul><h3><span id="相关概念">相关概念</span></h3><ul><li>软链接 vs 硬链接</li><li>File flag</li><li><a href="/2016/05/31/unix-standard-input-output-redirection/" title="标准输入输出重定向（Redirection）">标准输入输出重定向（Redirection）</a> </li><li><a href="/2016/05/24/learning-shell-in-mac-ls/" title="通配符">通配符</a> </li></ul><h2><span id="参考资料">参考资料</span></h2><ol><li><p><a href="http://stackoverflow.com/questions/8051145/what-are-the-differences-between-using-the-terminal-on-a-mac-vs-linux" target="_blank" rel="external">What are the differences between using the terminal on a mac vs linux?</a></p></li><li><p><a href="http://linuxcommand.org/index.php" target="_blank" rel="external">Linux Command</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;干嘛要学命令&quot;&gt;干嘛要学命令&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;切换到mac下工作有一段时间了，难免要在终端中做一下操作，目前掌握的一些比较简单的命令行有时已经难以驾驭一些比较复杂的操作了。有必要系统得过一遍主要的一些命令。&lt;/p&gt;
&lt;p&gt;除了装逼意外，命令
      
    
    </summary>
    
      <category term="编程工具" scheme="http://zhengyi.me/categories/%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="shell" scheme="http://zhengyi.me/tags/shell/"/>
    
      <category term="mac" scheme="http://zhengyi.me/tags/mac/"/>
    
      <category term="terminal" scheme="http://zhengyi.me/tags/terminal/"/>
    
  </entry>
  
  <entry>
    <title>读书方法的一些思考</title>
    <link href="http://zhengyi.me/2016/05/14/some-thought-about-reading/"/>
    <id>http://zhengyi.me/2016/05/14/some-thought-about-reading/</id>
    <published>2016-05-14T13:07:04.000Z</published>
    <updated>2016-05-15T13:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="引子">引子</span></h2><p>今天读完了《精进》这本书，可以说在读的过程中确实领悟到了很多作者想要表达的一些观点。也有一些自己的思考，也学到了一些新的知识点，也有一些醍醐灌顶的时刻。但是当我合上这本书的时候，我问自己这本书讲了什么主要的观点？我竟回想不起多少内容。</p><p>有种极度恐惧的感觉，因为自以为花了一些时间认真阅读了这本书，在读书的过程中也做了一些简单的笔记，并把读书过程中的一些想法记录了下来。但是读完却发现所记住的东西甚少，或者说可以提取出来的东西甚少。也许这些知识在大脑中的某一个地方待着，但是我无法通过这本书与其联系起来从而提取出来。</p><p>当我慌的时候，我去上网进行了搜索了“如何读书 有效”，“读书 容易忘”。对于搜索到的结果也只是匆匆地进行了阅读，寄希望于能够从中找到一个两个好的办法能够帮助我获得更好的阅读效果。</p><p>这个行为明显是不明智的，去搜索关于如何阅读一本书的资料没问题，但是在这个觉得慌张的时候别人的观点往往不能够很好地帮助到你。特别是你抱着一个很功利的心态去试图获取一个复杂问题的简单解决方案的时候，往往不能够得到一个好结果。</p><h2><span id="反思">反思</span></h2><p>这个时候应该做的就是想现在这样，安静的进行思考。因为对于自己阅读中的问题，自己其实是最清楚的，可以观察自己的阅读行为来找出一个适合自己的方法。即使找不到也可以想一个可行的方案去做。能够想到这个层面，从某种角度上说明了这本书的阅读有一定的效果，作者的某一些观点虽不能够完全的表达出来，但也已经对我的想法产生了影响。也许即使你想不起来这本书讲了哪些具体的东西也没关系，可能你已经将这些观点用自己的方式记住了，在将来的某个时间点碰到某个问题的时候能够提取出来。</p><p>那么这个问题的关键就从如何在阅读完一本书以后想起来这本书的具体内容，变成了如何将作者的观点转化成自己的想法。那么阅读中的思考就变得非常的关键，有思考才能将自己已有的知识与其发生联系。</p><h3><span id="阅读的方法">阅读的方法</span></h3><p>我觉得阅读的时候可以尝试的阅读方法有一下几种：</p><ol><li>初次阅读的时候，最好带有目的性的去阅读。即希望从书中获得什么知识，希望作者帮助你解决那些困惑。带着疑问去读会让你更加容易把读到的知识和已有的知识进行联系。</li><li>序和前言最好要读，接着就是目录。要在读之前对于章节的结构有一个大概的认识。</li><li>阅读的过程中不要过多的进行标注重点，适当的在读到有感悟的时候在书上做笔记。阅读的时候备好纸笔，当有一些想法从大脑中迸发出来的时候，及时的记录下来，然后回去继续阅读。</li><li>读的时候如果走神的话马上停止阅读，走神的阅读纯属浪费时间。</li><li>频繁的对自己读到的文字进行简单的总结，特别是在每节、每章之后，想想作者想表达的是什么？作者前后文之间的逻辑。</li><li>有条件的话，在阅读完一章以后在脱离书本的情况下回想一下这一章讲了什么，有什么知识点以及之间的联系。可以画图、写字、形式不限。</li><li>如果喜欢可以跳着读。</li><li>读完全本，合上书本，极力回想。然后去重新翻一下书本/每章做的笔记，做一下思维导图。</li><li>如果有必要快速重读一遍，在觉得重要的章节进行深度阅读。我觉得重读最好不要在读完一遍之后马上进行，而是隔上一段时间再进行。这会有更好的效果。</li><li>重复5~10。</li></ol><h3><span id="阅读的作用">阅读的作用</span></h3><p>顺便理一理下关于阅读作用的想法</p><ol><li>纯属娱乐。</li><li>希望作者能够帮助解决某个疑问、问题。</li><li>希望从书中汲取某一个领域的知识。</li><li>在阅读的过程中进行思考进而产生新的想法、疑问等。</li><li>可以看到到更多不一样的世界和可能性。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;引子&quot;&gt;引子&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;今天读完了《精进》这本书，可以说在读的过程中确实领悟到了很多作者想要表达的一些观点。也有一些自己的思考，也学到了一些新的知识点，也有一些醍醐灌顶的时刻。但是当我合上这本书的时候，我问自己这本书讲了什么主要的观点
      
    
    </summary>
    
      <category term="阅读相关" scheme="http://zhengyi.me/categories/%E9%98%85%E8%AF%BB%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="阅读" scheme="http://zhengyi.me/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="思考" scheme="http://zhengyi.me/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
</feed>
