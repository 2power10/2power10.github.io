
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>yi&#39;s weblog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Yi">
    

    
    <meta name="description" content="关于编程、技术、读书、思考的一些文字，以及一些我觉得有趣的东西。">
<meta property="og:type" content="website">
<meta property="og:title" content="yi&#39;s weblog">
<meta property="og:url" content="http://zhengyi.me/page/2/index.html">
<meta property="og:site_name" content="yi&#39;s weblog">
<meta property="og:description" content="关于编程、技术、读书、思考的一些文字，以及一些我觉得有趣的东西。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="yi&#39;s weblog">
<meta name="twitter:description" content="关于编程、技术、读书、思考的一些文字，以及一些我觉得有趣的东西。">

    
    <link rel="alternative" href="/atom.xml" title="yi&#39;s weblog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="yi&#39;s weblog" title="yi&#39;s weblog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="yi&#39;s weblog">yi&#39;s weblog</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/about">关于我</a></li>
					
						<li><a href="/atom.xml">RSS</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:zhengyi.me">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/28/effective-cpp-reading-notes-2/" title="《Effective C++》读书笔记(2)" itemprop="url">《Effective C++》读书笔记(2)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Yi" target="_blank" itemprop="author">Yi</a>
		
  <p class="article-time">
    <time datetime="2016-06-28T13:55:42.000Z" itemprop="datePublished"> 发表于 2016-06-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3><span id="条款4确定对象被使用前已先被初始化">条款4：确定对象被使用前已先被初始化</span></h3><blockquote>
<ul>
<li>为内置型对象进行手工初始化，因为C++不保证初始化它们。</li>
<li>构造函数最好使用成员初值列（member initialization list），而不是在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，起排序次序应该和它们在class中的声明次序相同。</li>
<li>为了免除“跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象。</li>
</ul>
</blockquote>
<p>内置对象指的是C++自带的类似于int，double的类型。这些类型变量如果没有进行初始化，其值是未定义的，如果对其进行读取会导致不明确的行为（undefined behavior）。所以必须要保证读取内置对象前，其被初始化过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x; 		// bad code</span><br><span class="line">int x = 0; 	// good code</span><br></pre></td></tr></table></figure>
<p>对于非内置类型，初始化的任务则是由构造函数负责的。包括STL库里的一些类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string str;		//it&apos;s ok</span><br><span class="line">std::string str = &quot;&quot;; 	//it&apos;s also ok</span><br><span class="line">Class1 obj;</span><br></pre></td></tr></table></figure>
<p><strong>类成员变量初始化 vs 赋值</strong></p>
<p>类的成员变量在进入构造函数之前已经已经被初始化，所以如果在构造函数内进行”初始化“的的话其实是进行赋值，会带来额外的开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Entry &#123;</span><br><span class="line">public:</span><br><span class="line">	Entry();</span><br><span class="line">private:</span><br><span class="line">	std::string name;</span><br><span class="line">	int value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry::Entry() &#123;</span><br><span class="line">	name = &quot;default&quot;; //</span><br><span class="line">	value = 0;        // not good </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Entry::Entry()</span><br><span class="line">  : name(&quot;default&quot;)</span><br><span class="line">  , value(0)</span><br></pre></td></tr></table></figure>
<p>至于作者提到的初值列中的顺序需要与class内变量声明的顺序保持一致是因为c++总是按照class内变量声明的顺序对变量，所以为了避免带来迷惑以及容易检查是否漏掉变量未初始化，最好将初值列顺序与class内变量声明顺序保持一致。</p>
<p><strong>non-local static 对象的初始化</strong></p>
<p>不同<strong>编译单元</strong>内定义的<strong>non-local static</strong>对象初始化次序未定义。</p>
<p><em>编译单元</em></p>
<p>编译单元是指产出单一目标文件（object file）的那些源码，基本上是它的源文件加上其所含入的头文件。</p>
<p><em>non-local static 对象</em></p>
<p>除了定义在函数内的static变量，其他的static变量均是non-local static对象，包括global对象、定义域namespace作用域内的对象、class内的、文件作用域内的static对象。</p>
<p>次序未定义会导致一个问题，就是如果你需要在一个编译单元内使用另一个编译单元的静态变量，则很有可能你在调用的时候其还没有初始化。这种情况你可以通过使用返回一个local static变量的reference的方法来得到，这个方法就是单例的常见使用场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileSystem &amp;tfs() &#123;</span><br><span class="line">   static FileSystem fs;</span><br><span class="line">   return &amp;fs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这个还有一个问题就是static在多线程的情况下会出现不确定性，所以最好在程序启动时先以单线程的方式调用一遍。</p>
<p><strong>总之</strong>，non-local static对象最好只在一个编译单元内使用，如果需要跨编译单元使用，则使用单的方法替代。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C++</a><a href="/tags/编程语言/">编程语言</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/06/28/effective-cpp-reading-notes-2/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/24/effective-cpp-reading-notes-1/" title="《Effective C++》读书笔记(1)" itemprop="url">《Effective C++》读书笔记(1)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Yi" target="_blank" itemprop="author">Yi</a>
		
  <p class="article-time">
    <time datetime="2016-06-24T12:31:22.000Z" itemprop="datePublished"> 发表于 2016-06-24</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="让自己习惯c">让自己习惯C++</span></h2><h3><span id="条款01视c为一个语言联邦">条款01：视C++为一个语言联邦</span></h3><blockquote>
<ul>
<li>C++ 高效编程守则是状况而变化，取决于你使用C++的哪一个部分。</li>
</ul>
</blockquote>
<p>C++并不是一个单一范式编程语言，它同时支持过程形式（procedural），面向对象设计（object-oriented）、函数形式（functional）、泛型形式（generic），元编程形式（meta-programming）。</p>
<p>所以作者认为并不是每一个规则都是适用于所有的这些范式的，那么我们可以将C++语言分为一下几种次语言：</p>
<ul>
<li>C</li>
<li>Object-Oriented C++</li>
<li>Template C++</li>
<li>STL</li>
</ul>
<h3><span id="条款02尽量以constenuminline替换define">条款02：尽量以const，enum，inline替换#define</span></h3><blockquote>
<ul>
<li>对于单纯常量，最好以const对象或enums替换#define</li>
<li>对于形似函数的宏（macros），最好改用inline函数替换#define</li>
</ul>
</blockquote>
<p><strong>#define的缺点：</strong></p>
<ol>
<li>define 定义的值无法被编译器和调试器看到，出问题了很麻烦。</li>
<li>没有良好的封装新，不能控制作用域。</li>
</ol>
<p><strong>const</strong></p>
<p>使用const我可以这样声明一个常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const std::string ProductName(&quot;Mango Game&quot;);</span><br><span class="line">const double Pi = 3.1415;</span><br></pre></td></tr></table></figure>
<p>还可以声明一个类的专属常量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//Header</span><br><span class="line">class Game &#123;</span><br><span class="line">private:</span><br><span class="line">	static const int MaxGamePlayer ;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//cpp file</span><br><span class="line">const int Game::MaxGamePlayer = 5;</span><br></pre></td></tr></table></figure>
<p><strong>enum hack</strong></p>
<p>如果需要编译时使用到常量就需要enum hack这个技巧，实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">    enum &#123; NumTurns = 5&#125;</span><br><span class="line">    int scores[NumTruns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>inline function</strong></p>
<p>有一些宏长得很像函数，这种宏有类型安全问题和不可预料行为两个问题。可以使用inline function来替代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个MAX宏很不好，会出现奇怪的一些问题且无法调试</span><br><span class="line">#define MAX(a,b) ((a) &gt; (b) ? (a) : (b))</span><br><span class="line"></span><br><span class="line">//Good</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline T Max(const T&amp; a, const T&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    return (a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><span id="条款3尽可能使用const">条款3：尽可能使用const</span></h3><blockquote>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。</li>
<li>编译器强制实施bitwise constness，但你编写程序时应该使用“概念上的常量性”（conceptual constness）。</li>
<li>当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>
</blockquote>
<p>const提供一种语义上的约束，它能够约束变量使用者的行为。当它作用于针、智能指针、迭代器上的时候可以指向指针本身也可以是指针指向物。作者提出了一个识别的技巧：<em>如果关键字const出现在星号左边，表示被指物是常量；如果出现在星号右边，表示指针本身是常量。</em></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">char greeting[] = &quot;Hello&quot;</span><br><span class="line">char *p = greeting;			//non const point, const data</span><br><span class="line">const char * p = greeting;	//non const point, const data </span><br><span class="line">char const * p = greeting;	//non const point, const data</span><br><span class="line">char * const p = greeting;	//const point, non const data</span><br><span class="line">const char* const p = greeting; //const point, const data</span><br><span class="line"></span><br><span class="line">const std::vector&lt;int&gt;::iterator it;		// --&gt; T * const p</span><br><span class="line">*it = 10; 	//合法</span><br><span class="line">it++;		//不合法</span><br><span class="line">std::vector&lt;int&gt;::const_iterator it;		// --&gt; const T * p</span><br><span class="line">it = 10;	//不合法</span><br><span class="line">it++;		//合法</span><br><span class="line"></span><br><span class="line">std::shared&lt;T&gt; p1;</span><br><span class="line">std::shared&lt;const T&gt; p;	// --&gt; const T *p</span><br><span class="line">p = p1;			//合法</span><br><span class="line">*p.get() = x;	//不合法</span><br><span class="line">const std::shared&lt;T&gt; p; // --&gt; T* const p</span><br><span class="line">p = p1;			//不合法</span><br><span class="line">*p.get() = x;	//合法</span><br></pre></td></tr></table></figure>
<p>有点头晕，我有一个不是很恰当地记忆方法。可以把<code>const</code>看成修饰它右边所有内容的，以<code>const char* p</code>为例，把<code>p</code>看成一个指针，而<code>*p</code>则是数据，所以<code>const</code>是修饰数据的。而<code>char * const p</code>中，<code>const</code>右边只有<code>p</code>，所以它只是限制指针本身的。</p>
<h4><span id="bitwise-constness-vs-logical-constness">bitwise constness vs logical constness</span></h4><p>当限制一个成员函数为const，编译器会执行bitwise constness，即检查函数内部是否修改了类的成员变量。但是写代码的时候应该注意逻辑上的常量限制，比如说一个你返回了一个指向内部变量的指针，这个函数虽然符合编译器的const限制但却不是很好的一个写法。</p>
<p>[to be continued]</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程语言/">编程语言</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C++</a><a href="/tags/编程语言/">编程语言</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/06/24/effective-cpp-reading-notes-1/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/06/learning-shell-grep/" title="Mac 命令学习 - grep" itemprop="url">Mac 命令学习 - grep</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Yi" target="_blank" itemprop="author">Yi</a>
		
  <p class="article-time">
    <time datetime="2016-06-06T13:45:02.000Z" itemprop="datePublished"> 发表于 2016-06-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="背景知识">背景知识</span></h2><p>grep是linux中常用的文本处理的工具，与之类似的工具有sed和awk，它们分别适用于不同的场景。同时要想很好的使用grep等文本处理工具，需要对正则表达式有一定的了解。</p>
<h3><span id="grep-vs-sed-vs-awk">grep vs sed vs awk</span></h3><p>grep主要用于对文本、文件进行搜索，查找出符合要求的字符串并输出相关的内容。</p>
<p>sed和awk则是更强大文本处理工具，适用于更复杂的场景。sed是一个基于字符流的处理工具（stream editor），不仅可以查找文字还可以对文本进行操作，比如说修改、删除、插入等。awk则是更加强大的工具，它本身是一个完整的编程语言，可用于对数据的提取处理然后生成一些报表，主要针对类csv格式的文件。</p>
<h3><span id="正则表达式">正则表达式</span></h3><p>to be written</p>
<h3><span id="grep的种类">grep的种类</span></h3><ul>
<li><strong>grep</strong> | grep使用简单的模式和正则表达式进行搜索。</li>
<li><strong>egrep</strong> | egrep使用拓展版的正则表达式，包含更多的正则表达式功能。</li>
<li><strong>fgrep</strong> | fgrep是加速版的grep，主要适用于简单的模式匹配。</li>
<li><strong>zgrep, zegrep, zfgrep</strong> | 与grep, egrep, fgrep 效果相同，只是可以接受一个由compress或gzip压缩出来的压缩包进行搜索。在现在的操作系统中，多种的grep使用的是同一个binary，而不是不同的binary。比如说<code>grep -E</code>其实等效于egrep，<code>grep -F</code>等效于fgrep。</li>
</ul>
<h2><span id="常用参数">常用参数</span></h2><p><code>-A num, --after-context=num</code> - 打印出找到的匹配行后num行。这个跟<code>-B</code>，<code>-C</code>类似功能，主要用于查看上下文。</p>
<p><code>-B num, --before-context=num</code> - 打印出找到的匹配行前num行。</p>
<p><code>-C[num, --context=num]</code> - 打印出找到的匹配行前后num行，相当于<code>-A num -B num</code>。</p>
<p><code>-c, --count</code> - 统计出匹配的总行数，同一行有两个匹配也只算一行。</p>
<p><code>--colour=[when, --color=[when]]</code> - 将匹配的字符标记为彩色，when可以是’never’，‘auto’或’always’。</p>
<p><code>-e pattern, --regexp=pattern</code> - 制定在搜索中使用的匹配模式，多用于指定多个匹配模式的情况。</p>
<p><code>-H</code> - 在每一行前面打印出匹配的文件名，在多个文件的情况下这个是默认选项。</p>
<p><code>-h</code> - 在多个文件的情况下不打印出匹配的文件名。</p>
<p><code>-n</code> - 打印出匹配所在行的行数。</p>
<p><code>-i, --ignore-case</code> - 查找时忽略大小写。</p>
<p><code>-R, -r, --recursive</code> - 递归的去查找子目录下的文件。</p>
<p><code>-v, --invert-match</code> - 打印出不匹配的行。</p>
<p><code>-w, --word-regexp</code> - 只匹配整个单词。</p>
<h2><span id="案例学习">案例学习</span></h2><p>实验文件，随便找了一个莎士比亚的十四行诗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat demofile</span><br><span class="line">sonnet 18</span><br><span class="line"></span><br><span class="line">Shall I compare thee to a summer&apos;s day? </span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">Rough winds do shake the darling buds of May, </span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line"></span><br><span class="line">Sometime too hot the eye of heaven shines, </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d </span><br><span class="line"></span><br><span class="line">But thy eternal summer shall not fade </span><br><span class="line">Nor lose possession of that fair thou owest; </span><br><span class="line">Nor shall Death brag thou wander&apos;st in his shade, </span><br><span class="line">When in eternal lines to time thou growest: </span><br><span class="line"></span><br><span class="line">So long as men can breathe or eyes can see, </span><br><span class="line">So long lives this and this gives life to thee.</span><br><span class="line">$ cp demofile demofile2</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在文件中搜索某个字符串。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">Nor shall Death brag thou wander&apos;st in his shade, </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配整个单词。</p>
<p> 上面的例子中搜索and这个字符串匹配了wander这个单词，如果我们只想搜and这个单词可以使用<code>-w</code>参数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -w &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略大小写</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -i -w &quot;and&quot; demofile</span><br><span class="line">Thou art more lovely and more temperate: </span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">So long lives this and this gives life to thee.</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用正则表达式</p>
<p> 只要把匹配的字符串换成需要的正则表达式即可。比如说需要搜索以And开头的行。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep &quot;^And&quot; demofile</span><br><span class="line">And summer&apos;s lease hath all too short a date: </span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines,</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示上下文</p>
<p> 有时候搜出来需要看看上下文，可以利用上面提到的<code>-B</code>，<code>-A</code>和<code>-C</code>来实现。</p>
<p> 比如想要找出包含”nature”的句子并打印出上下两行。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -C2 &quot;nature&quot; demofile</span><br><span class="line">And often is his gold complexion dimm&apos;d; </span><br><span class="line">And every fair from fair sometime declines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d </span><br><span class="line"></span><br><span class="line">But thy eternal summer shall not fade</span><br></pre></td></tr></table></figure>
</li>
<li><p>统计出匹配的总行数</p>
<p> 比如说想要统计出现”to”的行数</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -c &quot;to&quot; demofile</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>如果想要统计出现的总次数的话，grep本身没有办法满足这个需求，需要使用sed或awk来实现。或者结合wc来实现。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -o &quot;to&quot; demofile| wc -l</span><br><span class="line">       5</span><br></pre></td></tr></table></figure>
</li>
<li><p>高亮匹配文字</p>
<p> 高亮匹配文字可以让肉眼可以第一时间的看到匹配结果，利用–color=auto/always来实现。此处nature高亮状。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep --color=auto &quot;nature&quot; demofile</span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单匹配多个模式</p>
<p> 查找多个字符串可以使用<code>|</code>字符来进行简单的匹配。比如说<code>&quot;heaven|nature&quot;</code>表示匹配heaven或者nature。因为这个是正则表达式的拓展部分，所以需要使用<code>-E</code>或者egrep。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -E &quot;heaven|nature&quot; demofile</span><br><span class="line">Sometime too hot the eye of heaven shines, </span><br><span class="line">By chance or nature&apos;s changing course untrimm&apos;d</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂匹配多个模式</p>
<p> 需要找出符合多个模式的匹配。比如说，找出以”When”开头或者包含”fade”的行。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; demofile</span><br><span class="line">But thy eternal summer shall not fade </span><br><span class="line">When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出不满足条件的匹配</p>
<p>在一些情况下我们需要找出不满足某个条件的行，这个时候就可以用<code>-v</code>来实现了。</p>
<p>比如说想找出首字母不是大写字母的行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -v &quot;^[A-Z]&quot; demofile</span><br><span class="line">sonnet 18</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印出匹配所在行的行数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; -n demofile</span><br><span class="line">13:But thy eternal summer shall not fade </span><br><span class="line">16:When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印出文件名</p>
<p>进行多个文件搜索的情况下，默认会打印出文件名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ grep -e &quot;^When&quot; -e &quot;fade&quot; demofile demofile2</span><br><span class="line">demofile:But thy eternal summer shall not fade </span><br><span class="line">demofile:When in eternal lines to time thou growest: </span><br><span class="line">demofile2:But thy eternal summer shall not fade </span><br><span class="line">demofile2:When in eternal lines to time thou growest:</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>[EOF]</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程工具/">编程工具</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a><a href="/tags/mac/">mac</a><a href="/tags/terminal/">terminal</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/06/06/learning-shell-grep/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/03/learning-shell-rm-mv-mkdir/" title="Mac 命令学习 - mv, rm, mkdir" itemprop="url">Mac 命令学习 - mv, rm, mkdir</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Yi" target="_blank" itemprop="author">Yi</a>
		
  <p class="article-time">
    <time datetime="2016-06-03T14:25:48.000Z" itemprop="datePublished"> 发表于 2016-06-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="mv-move">mv （move）</span></h2><p>mv是用于移动文件的命令，mac下没有重命名的命令，所以很多时候mv也用来重命名文件。</p>
<p><strong>常用参数</strong></p>
<p><code>-f</code> - 强制覆盖不提醒<br><code>-i</code> - 覆盖目标文件前提醒<br><code>-n</code> - 不覆盖目标文件</p>
<p><strong>将n个文件移动到某个目录下</strong></p>
<p><code>mv file1 file2 file3 dir</code></p>
<p>如果目录不存在，会报错</p>
<p><strong>重命名/移动文件</strong></p>
<p><code>mv file1 file2</code></p>
<p>如果file2不存在则重命名为file2，如果存在则覆盖</p>
<p><strong>移动目录</strong></p>
<p><code>mv dir1 dir2</code></p>
<p>将dir1移动到dir2目录下，如果dir2不存在则是一个重命名的效果</p>
<h2><span id="rmremove">rm（remove）</span></h2><p>此命令用于删除文件和目录，与通配符结合使用时破坏很大，稍有不慎将酿成大错后悔莫及。</p>
<p>普通的删除只是将文件从文件系统中移除，磁盘上的那块空间并不会去动它。所以如果误删除的话，通过某一些还原工具是有可能找回来的。</p>
<blockquote>
<p>Linux并没有撤销删除命令，一旦你用<code>rm</code>命令将某个文件删除，你将很难恢复（mac可以通过特殊的数据还原工具）。如果错误的使用<code>rm</code>，特别是跟通配符结合使用的时候，将有可能造成极大的危害。<br>在<code>rm</code>中使用通配符之前，有一个有用的小诀窍：先将你的通配符用<code>ls</code>命令试试看，看一下所影响的文件。当你用<code>ls</code>测试过没问题以后，你可以直接把<code>ls</code>特换成<code>rm</code>。<sup><strong>[1]</strong></sup></p>
</blockquote>
<h3><span id="基本用法">基本用法</span></h3><p><code>rm [-dfiPRrvW] file ...</code></p>
<p><code>-f</code> - 强制删除，没有提示<br><code>-i</code> - 删除某个文件前请求确认<br><code>-P</code> - 粉碎性删除。删除文件前重新复写整个文件，往文件里不停写入<code>0xff</code>和<code>0x00</code>。这样删除的文件无法恢复。<br><code>-R</code> - 递归删除。如果指定的文件为目录，则删除目录下所有的文件及其子目录。</p>
<h2><span id="rmdirremove-directory">rmdir（remove directory）</span></h2><p>不要被这货的名字迷惑了，这个命令唯一的用途就是删除一个空白的文件夹。如果文件夹非空还是要用<code>rm -r</code>来删除，不知道它存在的意义是什么。</p>
<h2><span id="mkdirmake-directory">mkdir（make directory）</span></h2><p>顾名思义，创建文件夹使用。</p>
<h3><span id="基本用法">基本用法</span></h3><p><code>-p</code> 创建中间目录，比如<code>mkdir /path/with/many/layer</code>会帮你吧layer之前的所有层级的目录都创建出来。<br><code>-m</code> 制定文件夹的权限，详见chmod。</p>
<h2><span id="参考资料">参考资料</span></h2><ol>
<li><a href="http://linuxcommand.org/lc3_lts0050.php" target="_blank" rel="external">Manipulating Files</a></li>
</ol>
<p><strong>阅读更多</strong></p>
<a href="/2016/05/23/learning-shell-in-mac/" title="Mac/Linux 命令学习">Mac/Linux 命令学习</a>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程工具/">编程工具</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a><a href="/tags/mac/">mac</a><a href="/tags/terminal/">terminal</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/06/03/learning-shell-rm-mv-mkdir/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/06/02/learning-shell-chflags/" title="Mac 命令学习 - chflags" itemprop="url">Mac 命令学习 - chflags</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Yi" target="_blank" itemprop="author">Yi</a>
		
  <p class="article-time">
    <time datetime="2016-06-02T15:20:25.000Z" itemprop="datePublished"> 发表于 2016-06-02</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2><span id="背景知识">背景知识</span></h2><p>在<a href="/2016/05/24/learning-shell-in-mac-ls/" title="ls">ls</a>命令中有出现过一个<code>-O</code>的选项，即列出文件的file flag。这个File flag所为何物？</p>
<p>File flag是在BSD Unix中的概念，跟Linux系统中的attr是差不多的一个概念，是文件的一些标志位来存放文件的某些属性。chflags就是来修改这个file flag的。这个文件属性是跟文件系统相关的，所以这个命令在不同的文件系统上的支持程度不一样，体现在某一些flag在一些特定的文件系统上没有。<sup>[1]</sup></p>
<p>所有的属性都可以被超级管理员修改，有一些可以被文件的所有者修改。以下列出比较常用的几个属性<sup>[1]</sup>。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>ls中显示</th>
<th>chflags中使用</th>
<th>文件所有者能否修改？</th>
<th>详述</th>
</tr>
</thead>
<tbody>
<tr>
<td>隐藏</td>
<td>hidden</td>
<td>hidden</td>
<td>能</td>
<td>设置以后在GUI上看不到，ls依然可以看到d</td>
</tr>
<tr>
<td>系统级只能添加</td>
<td>sappnd</td>
<td>sappnd, sappend</td>
<td>否</td>
<td>设置以后此文件不能够截断或者复写(overwrite)，只能通过append模式添加内容</td>
</tr>
<tr>
<td>用户级只能添加</td>
<td>uappnd</td>
<td>uappnd, uappend</td>
<td>能</td>
<td>设置以后此文件不能够截断或者复写(overwrite)，只能通过append模式添加内容</td>
</tr>
<tr>
<td>系统级只读</td>
<td>schg</td>
<td>schg, schange, simmutable</td>
<td>否</td>
<td>不能够重命名、移动、删除、更改内容</td>
</tr>
<tr>
<td>用户级只读</td>
<td>uchg</td>
<td>uchg, uchange, uimmutable</td>
<td>能</td>
<td>不能够更改内容</td>
</tr>
</tbody>
</table>
<h2><span id="基本用法">基本用法</span></h2><p><code>chflags [-fhv] [-R [-H | -L | -P]] flags file</code></p>
<h2><span id="常用参数">常用参数</span></h2><p><code>-R</code> 递归修改参数中文件夹下面的所有文件和文件夹的属性</p>
<h2><span id="具体案例">具体案例</span></h2><p><strong>为一个文件添加一个属性</strong></p>
<p><code>chflags uchg file</code></p>
<p><strong>为一个文件删除一个属性</strong></p>
<p><code>chflags nouchg file</code></p>
<p>在属性名字前面添加no就可以将属性删除，如果这个属性本身已no开头（比如nodump）则去掉no。</p>
<p><strong>将文件夹及其文件夹下所有文件属性进行修改</strong></p>
<p><code>chflags -R uchg directory</code></p>
<h2><span id="参考资料">参考资料</span></h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Chattr" target="_blank" rel="external">chattr - Wikipedia</a></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/编程工具/">编程工具</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/shell/">shell</a><a href="/tags/mac/">mac</a><a href="/tags/terminal/">terminal</a>
  </div>

</div>




<div class="comments-count">
	
	  	<span></span>
		<a href="/2016/06/02/learning-shell-chflags/#disqus_thread" class="comments-count-link">Comments</a>
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  


  <div class="linkslist">
  <p class="asidetitle">公众号</p>
  <img width="100%" src="/img/wechat.logo.jpg" alt="ArmstrongNotes"/> 
</div>

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/心理学/" title="心理学">心理学<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/思考讨论/" title="思考讨论">思考讨论<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/编程工具/" title="编程工具">编程工具<sup>11</sup></a></li>
		  
		
		  
			<li><a href="/categories/编程语言/" title="编程语言">编程语言<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/阅读相关/" title="阅读相关">阅读相关<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/mac/" title="mac">mac<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/terminal/" title="terminal">terminal<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C++">C++<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/编程语言/" title="编程语言">编程语言<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/心理学/" title="心理学">心理学<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/思考方法/" title="思考方法">思考方法<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/思考/" title="思考">思考<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/读书笔记/" title="读书笔记">读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/非洲/" title="非洲">非洲<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/旅行/" title="旅行">旅行<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/毕淑敏/" title="毕淑敏">毕淑敏<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/随想/" title="随想">随想<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/gitflow/" title="gitflow">gitflow<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/项目控制/" title="项目控制">项目控制<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/阅读/" title="阅读">阅读<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/行动/" title="行动">行动<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Udacity/" title="Udacity">Udacity<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/前端/" title="前端">前端<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://blog.vicoder.com/" target="_blank" title="Victor Jiang">Victor Jiang</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.cnblogs.com/imjustice/" target="_blank" title="博客园主页">博客园主页</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m 10000000000 <br/>
			</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2017 
		
		<a href="/about" target="_blank" title="Yi">Yi</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-8661588-8', 'zhengyi.me');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
